{"meta":{"title":"点滴","subtitle":null,"description":null,"author":null,"url":"https://kangning1206.github.io"},"pages":[{"title":"Who i'm?","date":"2018-11-29T03:51:45.000Z","updated":"2018-12-12T03:35:44.000Z","comments":true,"path":"about/index.html","permalink":"https://kangning1206.github.io/about/index.html","excerpt":"","text":"wait for me back vue-charts demo vue-charts git"}],"posts":[{"title":"面试题","slug":"interview","date":"2018-12-22T09:30:50.000Z","updated":"2018-12-23T09:06:17.000Z","comments":true,"path":"2018/12/22/interview/","link":"","permalink":"https://kangning1206.github.io/2018/12/22/interview/","excerpt":"","text":"说明：面试题目，解决方法，我从招聘方角度，总结考点并且给出方法； javascipt 查找一个字符串中，出现次数最多的字符以及次数 考点：去重，比大小 12345678910111213141516171819202122232425262728293031323334353637/** * [maxCountChar 查找一个字符串中，出现次数最多的字符以及次数] * @param &#123;[type]&#125; str [description] * @return &#123;[type]&#125; [返回结果对象，&#123;name,count&#125; 包括最大字符和次数] */function maxCountChar(str) &#123; // 利用对象属性不可以重复特点，不存在则为1，存在则++; let obj = &#123;&#125;; for (let i = 0; i &lt; str.length; i++) &#123; let key = str[i]; if (obj[key]) &#123; obj[key]++; &#125; else &#123; obj[key] = 1; &#125; &#125; // 初始化字符是空，次数0; let maxStr = &#123; name: '', count: 0 &#125;; // 查找最大的数字 for (let key in obj) &#123; if (obj[key] &gt; maxStr.count) &#123; maxStr.name = key; maxStr.count = obj[key]; &#125; &#125; return maxStr;&#125;// console.log(maxCountChar('1a1ba2ca'));// &#123;name: \"a\", count: 3&#125; 数组去重 考点：ES6 Set 集合不允许重复对象，或者使用对象属性不重复特点。常规新的数据循环比对不适合； 123456let arr = [1,34,1,'a','b','c','a'];let newArr = [...new Set(arr)]// newArr是无重复数组； 返回结果 考点：delete 操作符, 删除对象的某个属性，但并不是任意属性都能删除,只有enumerable的属性才可以移除； let 变量不可以被移除； 语法，对于12delete object.propertydelete object[&apos;property&apos;] 1234(function(x) &#123; delete x; console.log(x);&#125;)(9 - 7); 控制台打印2； 预编译 记住四步，函数内同名变量、函数名、变量提升等问题都可解释； 创建AO对象； 找形参和变量声明，将变量和形参作为AO属性名称，值为undefined; 将实参和形参值统一，即给形参赋值； 在函数体内找函数声明，值赋予函数体; 第一题 123456function foo(x) &#123; console.log(x); var x = 10; console.log(x);&#125;foo(20); 第一步: 创建函数foo的AO:{ } 第二部： AO:{ x:undefined //此处x是形参声明} 第三部： AO:{ x:undefined //此处x是变量声明，覆盖了前者同名} 第四部： 将实参合形参统一，给AO.x赋值20； 第五部： 打印x,此时是20；给AO.x赋值10；打印x,此时是10； 第二题 123456789function foo(x) &#123; console.log(x); var x = 10; console.log(x); function x() &#123; &#125;&#125;foo(20); 第一步: 创建函数foo的AO:{ } 第二部： AO:{ x:undefined //此处x是形参声明} 第三部： AO:{ x:undefined //此处x是函数内声明，覆盖了前者同名} 第四部： 将实参合形参统一，给AO.x赋值20； 第五部： AO:{ x:function(){} //此处x是函数声明，覆盖了前者同名} 第六步： 打印x,此时AO.x 是函数function(){},输出f x(){}给AO.x赋值10；打印x,此时是10； foo.x 值是什么？ 考点：引用赋值、变量赋值引用类型，连续等号 123var foo = &#123;n: 1&#125;;var bar = foo;foo.x = foo = &#123;n: 2&#125;; 返回undefined; 分析： 第一行和第二行 foo和bar指向同一个引用地址； 第三行，同时给foo.x和foo设置值{n: 2}，foo.x指向的引用等于bar.x,值是{n:2},变量foo重新设置引用{n:2} 结果是123456bar= &#123; n: 1, x: &#123;n: 2&#125; &#125;foo = &#123;n: 2&#125;// foo ===bar.x 返回true，两个指向同一个引用 打印结果 考点：同步异步，Javascript是单线程，异步任务采用队列方式，空闲时再执行队列；推荐文章 难点：setTimeout和Promise的优先级别 1234567891011// one four three twoconsole.log(&apos;one&apos;);setTimeout(function() &#123; console.log(&apos;two&apos;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&apos;three&apos;);&#125;)console.log(&apos;four&apos;); 打印结果 考点：await，await会暂停当前async函数的执行，等待后面的Promise的计算结果返回以后再继续执行当前的async函数。并不是等待所有，只等待Promise类型； Promise和async/await 适合大量连续（顺序）执行异步操作； 12345678910111213141516171819202122232425async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);&#125;async function async2() &#123; console.log(&apos;async2&apos;);&#125;console.log(&quot;script start&quot;);setTimeout(function() &#123; console.log(&quot;settimeout&quot;);&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(&quot;promise1&quot;); resolve();&#125;).then(function() &#123; console.log(&quot;promise2&quot;);&#125;);console.log(&apos;script end&apos;); 结果： script startasync1 startasync2promise1script endpromise2async1 endsettimeout 在输出 async2后，等待后边promise,所以输出promise1 HTML 什么是doctype？ doctype 是文档类型；声明文档类型是必要的，主要目的是防止浏览器在渲染文档时，切换到“怪异模式(兼容模式)”；明确的设置doctype，确保浏览器按照最佳的规范进行渲染； 同一个类型浏览器，厂家为了兼容性，会有多个或兼容的方案来渲染页面；通知设置doctype来选择渲染引擎； data attributes有什么好处？ 扩展了标签属性，允许在元素上存储数据，扩张性强； 语法简单，html标签属性中，以data-开头的属性是数据属性； JavaScript 可访问，使用dom节点上dataset属性集访问； css也可以访问。 Describe the difference between , and . async 字面量即异步的，js执行是同步的阻塞的，增加此属性后，顺序被调整；该属性需要src外部脚本，对内联脚本无效； defer 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。 crossorigin=”anonymous” 请求头中设置Origin 属性；cors检查时使用； Why is it generally a good idea to position CSS s between and JS s just before ? Do you know any exceptions? 浏览器引擎原理讲起； dom渲染和js执行是互斥的，不可能一遍渲染一遍执行js，不符合常理，因此js执行过程中，会停止dom渲染，即所谓的阻塞；那么我们将脚本沉入底部，dom和css完成结合后，在执行js动作； css不会影响dom，但会影响渲染，如果css下载超时，则放弃此css节点文本；尽可能早的完成css 数的建立，放置在页面顶部是合理的； img标签的srcset属性？ 很少使用，但确实存在； 在srcset语法是以逗号分隔的一个或多个字符串列表表明一系列用户代理(一般是浏览器)使用的可能的图像。包括一个宽度描述符，一个图片地址； 根据浏览器窗口大小使用合适的尺寸图片； 1&lt;img src=\"small.jpg \" srcset=\"big.jpg 1440w, middle.jpg 800w, small.jpg 1x\" /&gt;","categories":[],"tags":[]},{"title":"prototype关系图","slug":"prototype-img","date":"2018-12-08T09:43:05.000Z","updated":"2018-12-09T02:26:07.000Z","comments":true,"path":"2018/12/08/prototype-img/","link":"","permalink":"https://kangning1206.github.io/2018/12/08/prototype-img/","excerpt":"","text":"js中对象、构造函数prototype、Function、Object关系。","categories":[],"tags":[]},{"title":"设计模式-单例模式","slug":"designpattern-1","date":"2018-12-07T11:40:53.000Z","updated":"2018-12-07T11:55:29.000Z","comments":true,"path":"2018/12/07/designpattern-1/","link":"","permalink":"https://kangning1206.github.io/2018/12/07/designpattern-1/","excerpt":"","text":"概念单例模式，顾名思义，只创建一个实例，不允许创建多个，应用在拥有一个全局配置，比如系统配置文件； 更多应用场景 https://www.cnblogs.com/restartyang/articles/7770856.html 介绍的很多； 基本思路利用立即执行函数与闭包，返回一个对象，在闭包内控制实例化； 分类根据创建时机场景，分类以下两个 赖汉式：需要时创建对象 饿汉式：一开始立刻创建对象 实现赖汉式12345678910111213141516171819202122232425262728293031323334353637// 懒汉式，在需要使用时才会创建对象，不会提前创建var singleton = (function() &#123; var instance = null; // bengin: 单例实现类 // 单例模式只需要替换掉类实现，其他地方不用修改 /** * [Singleton description] * @param &#123;[type]&#125; options [description] */ function Singleton(options) &#123; options= options|| &#123;&#125;; this.name = options.name || &apos;单例类属性&apos;; &#125; // 方法 Singleton.prototype.say = function() &#123; console.log(&apos;我是单例模式=&apos;,this.name); &#125;; // end: 单例实现类 return &#123; getInstance: function(options) &#123; if (!instance) &#123; // new 一个实例对象，此处是是使用new还是&#123;&#125;生成，看业务场景，简单的使用&#123;&#125;，需要继承时使用构造函数 instance = new Singleton(options); &#125; return instance; &#125; &#125;;&#125;)();// 使用var obj = singleton.getInstance(&#123;name:&apos;我是自定义&apos;&#125;);obj.say();","categories":[],"tags":[]},{"title":"deepclone","slug":"deepclone","date":"2018-12-06T09:33:49.000Z","updated":"2018-12-06T09:58:07.000Z","comments":true,"path":"2018/12/06/deepclone/","link":"","permalink":"https://kangning1206.github.io/2018/12/06/deepclone/","excerpt":"","text":"JavaScript 对象拷贝，浅拷贝比较见到那，for in 循环直接复制，但局限在值类型，对于数组和object 类型，则由于引用，并没有达到真正的拷贝； 思路 定义一个deepclone 克隆函数，参数为克隆源头，帮助我们复制； for in 源对象，如果直接属性是简单类型则，则直接赋值；否则递归，进一步分析此属性对应值，在进行for in； 返回拷贝后对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081var obj = &#123; name: &apos;aaa&apos;, age: 18, baby: false, card: [&apos;master&apos;, &apos;visa&apos;, &#123; a: 1 &#125;], wife: &#123; name: &apos;lp&apos;, son: &#123; name: &apos;json&apos; &#125; &#125;, haha: /^Chapter [1-9][0-9]&#123;0,1&#125;$/&#125;;var nobj = deepclone(obj);console.log(&apos;origin =&apos;, obj);console.log(&apos; clone =&apos;, nobj);/** * [deepclone 深度拷贝] * @param &#123;[type]&#125; origin [原始对象] * @param &#123;[type]&#125; target [新对象] * @return &#123;[type]&#125; [clone对象] */function deepclone(origin, target) &#123; // 容错，未定义 target 时，如果 orgin 是数组初始化为[],其他为&#123;&#125; target = target || (isArray(origin) ? [] : &#123;&#125;); // 执行拷贝，数据存储在 target shallowCopy(origin); /** * [shallowCopy description] * @param &#123;[type]&#125; oriObj [description] * @return &#123;[type]&#125; [description] */ function shallowCopy(oriObj) &#123; for (var props in oriObj) &#123; if (oriObj.hasOwnProperty(props)) &#123; // 直接拷贝 var objType = getValueType(oriObj[props]); if (objType == &apos;simple&apos;) &#123; target[props] = oriObj[props]; &#125; else &#123; // 对象型，递归拷贝 target[props] = deepclone(oriObj[props], target[props]); &#125; &#125; &#125; &#125; /** * [getValueType 获取数据类型，分为两大类，simple类型直接使用，其他则递归] * @param &#123;[type]&#125; value [description] * @return &#123;[type]&#125; [description] */ function getValueType(value) &#123; var nameType = Object.prototype.toString.call(value); var objType = &apos;simple&apos;; switch (nameType) &#123; case &apos;[object Number]&apos;: case &apos;[object Boolean]&apos;: case &apos;[object String]&apos;: case &apos;[object Undefined]&apos;: case &apos;[object Null]&apos;: case &apos;[object RegExp]&apos;: objType = &apos;simple&apos;; break; default: objType = &apos;object&apos;; break; &#125; return objType; &#125; function isArray(value) &#123; return Object.prototype.toString.call(value) == &apos;[object Array]&apos;; &#125; // 返回拷贝对象 return target;&#125;","categories":[],"tags":[]},{"title":"margin-collapsing","slug":"margin-collapsing","date":"2018-12-03T03:43:46.000Z","updated":"2018-12-03T04:16:17.000Z","comments":true,"path":"2018/12/03/margin-collapsing/","link":"","permalink":"https://kangning1206.github.io/2018/12/03/margin-collapsing/","excerpt":"","text":"margin collapsing 块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠（因为这里触发了 块格式化上下文 Block Formatting Context， BFC）。 相邻元素 父子元素","categories":[],"tags":[]},{"title":"css-box 盒子塌陷","slug":"css-box","date":"2018-12-03T03:42:21.000Z","updated":"2018-12-03T08:49:04.000Z","comments":true,"path":"2018/12/03/css-box/","link":"","permalink":"https://kangning1206.github.io/2018/12/03/css-box/","excerpt":"","text":"盒子塌陷什么是盒子塌陷","categories":[],"tags":[]},{"title":"htmlTempleate","slug":"htmlTempleate","date":"2018-12-01T10:15:13.000Z","updated":"2018-12-01T12:28:30.000Z","comments":true,"path":"2018/12/01/htmlTempleate/","link":"","permalink":"https://kangning1206.github.io/2018/12/01/htmlTempleate/","excerpt":"","text":"推荐一种 react 或者 vue 渲染 html页面模板，目的接在提高用户体验和性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 文档类型默认Html5 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- 根据需要设置语言或者移除lang --&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;!-- 需要保留，页面编码格式，推荐uft-8 --&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- 针对IE8设置，其他浏览器无效 --&gt; &lt;!-- 如果IE有安装Google Chrome Frame，那么就走安装的组件 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;!-- SEO: 页面关键词 keywords --&gt; &lt;meta name=\"keywords\" content=\"your keywords\"&gt; &lt;!-- SEO: 页面描述内容 description --&gt; &lt;meta name=\"description\" content=\"your description\"&gt; &lt;!-- viewport 需要设置 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,user-scalable=no\" /&gt; &lt;!-- 页面标题 --&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 性能：DNS预获取，将网站中访问的资源服务器域名一一定义在此 --&gt; &lt;link rel=\"dns-prefetch\" href=\"//yourwebsite.com\"&gt; &lt;!-- 性能：预连接、与查询、预加载，注意：预查询、预加载 不等于提前执行，仅是资源准备就绪 --&gt; &lt;!-- preconnect: 预先建立tcp连接，根据需要，将网站访问资源服务器域名一一定义在此 --&gt; &lt;link rel=\"preconnect\" href=\"//yourwebsite.com\"&gt; &lt;!-- prefetch: 能够让浏览器预加载一个资源（HTML，JS，CSS或者图片等），可以让用户跳转到其他页面时，响应速度更快。 Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。 --&gt; &lt;link rel=\"prefetch\" href=\"//yourwebsite.com/chunk.css\"&gt; &lt;link rel=\"prefetch\" href=\"//yourwebsite.com/chunk.js\"&gt; &lt;!--当部分资源在页面加载完成后即刻需要时，也就说很有必要的资源。可以使用preload,as属性设置文件类型 preload不阻塞文档onload --&gt; &lt;link rel=\"preload\" href=\"//yourwebsite.com/chunk.css\" as=\"style\"&gt; &lt;link rel=\"preload\" href=\"//yourwebsite.com/chunk.js\" as=\"script\"&gt; &lt;link rel=\"preload\" href=\"//yourwebsite.com/image.png\" as=\"image\"&gt; &lt;!-- 应用css，头部不出现引用js文件，避免阻塞渲染 --&gt; &lt;link rel=\"stylesheet\" href=\"//yourwebsite.com/css/app.css\"&gt; &lt;!-- 站点：favicon --&gt; &lt;link rel=\"icon\" type=\"image/png\" sizes=32x32 href=\"/img/icons/favicon-32x32.png\"&gt; &lt;link rel=\"icon\" type=\"image/png\" sizes=16x16 href=\"/img/icons/favicon-16x16.png\"&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt;&lt;strong&gt;脚本不支持或被关闭时的提醒信息，可有可无。&lt;/strong&gt;&lt;/noscript&gt; &lt;!-- 应用入口元素 --&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- 底部引用脚本：初始化页面渲染完成后，在执行脚本 --&gt; &lt;script src=\"//yourwebsite.com/js/chunk-vendors.2ab46520.js\"&gt; &lt;/script&gt; &lt;script src=\"//yourwebsite.com/js/app.ff0e0ca9.js\"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"http概述","slug":"http1","date":"2018-11-27T07:30:21.000Z","updated":"2018-11-28T10:47:11.000Z","comments":true,"path":"2018/11/27/http1/","link":"","permalink":"https://kangning1206.github.io/2018/11/27/http1/","excerpt":"","text":"HTTP 的基本性质HTTP 是简单的节虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。 HTTP 是可扩展的节在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers达成语义一致，新功能就可以被轻松加入进来。 HTTP 是无状态，有会话的节HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。 注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。同一台机器cookie是相同了，这样服务器就能辨别客户端访问身份； HTTP 和连接节一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。 这也是为什么http协议是建立在tcp协议之上的原因，确保每次连接可靠，但无需实时可用； HTTP/1.0为每一个请求/响应都打开一个TCP连接，导致了2个缺点：打开一个TCP连接需要多次往返消息传递，因此速度慢。但当多个消息周期性发送时，这样就变得更加高效：暖连接比冷连接更高效。 上边我们说到，http 请求无需实时可用，但从实际网页需求来看，没此简历tcp连接需要3次握手，这种转身就忘记的特性，势必带来了效率问题，因此在http1.1中引入了长连接；也就说我们看到的头部 Connection: keep-alive 信息； 长连接和短连接Connection: keep-aliveConnection: close 为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。 http请求由于三部分组成： 请求行 HTTP请求是由客户端发出的消息，用来使服务器执行动作。比如：GET /background.png HTTP/1.0 起始行 (start-line) 包含三个元素：方法、目标(URL)、协议版本 请求头 headers 来自请求的 HTTP headers 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号 (‘:’) 和一个结构取决于 header 的值。 整个 header（包括值）由一行组成，这一行可以相当长。 请求体 body 请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。 http 响应 状态行 比如HTTP/1.1 404 Not Found。包含以下信息：协议版本 状态 状态文本； headers 与请求头规则一致； 响应体 body 响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。 http2http1.1 缺点 header 没有被压缩； 不同的请求，即使header 信息相似，仍然会重复传输，从共享角度看是显得多余的； http2 新特点 多路复用 HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 多路复用 (multiplexing) 的过程，它允许更有效的底层 TCP 连接。 HTTP/2 帧机制是在 HTTP/1.x 语法和底层传输协议之间增加了一个新的中间层，而没有从根本上修改它，即它是建立在经过验证的机制之上。 http2 不需要前端做任何升级，只有浏览器支持，服务器端开启，则自动切换到http2上，但必须是https协议网站； http 连接管理 包括：短连接、长连接、流水线，连接能管理的是客户端、服务器，中间的代理如果不支持时（路由器），则会使失效； http1.0 使用短连接（Connection: close），每次请求时，都需要优建立连接； http1.1 默认使用了长连接（Connection: keep-alive），第一次请求时，建立了连接且会保持一段时间，之后请求不在重复建立连接，节省很多开销； 流水线，多个连续的请求不用等待立即返回就可以被发送，这样就减少了耗费在网络延迟上的时间。但在http1.1中由于各种受限，可应用性没有展开。好的一点是在http2中得到了支持；默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。","categories":[],"tags":[]},{"title":"前端知识点分类","slug":"resource-md","date":"2018-11-27T01:48:25.000Z","updated":"2018-11-28T01:04:59.000Z","comments":true,"path":"2018/11/27/resource-md/","link":"","permalink":"https://kangning1206.github.io/2018/11/27/resource-md/","excerpt":"","text":"vue vue.js基本 vuex 数据状态管理 axios使用 vue-router pc端ui和移动端ui JavaScript 闭包 作用域、作用域链路 继承 es2015新特性 web原理 http 304缓存 cors共享 浏览器原理:https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ node koa.js 工程化 webpack 客户端es6，vue,react配置 服务器端es6 质量 eslint配置和常用标准 单元测试、覆盖率、用户测试：mocha,karma,e2e了解库 测试框架,比如 Mocha、Jasmine、Karma、Tape mock.js 工具 抓包工具，如charles使用 浏览器开发者工具 编辑器 检查 Cache 相关 HTTP 首部的工具. RedBot 其他 rest接口开发模式 学习网站https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview","categories":[],"tags":[]},{"title":"axios遇到OPTIONS请求","slug":"axios","date":"2017-06-09T08:36:39.000Z","updated":"2018-12-01T09:43:17.000Z","comments":true,"path":"2017/06/09/axios/","link":"","permalink":"https://kangning1206.github.io/2017/06/09/axios/","excerpt":"","text":"axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。大部分前端工程师在使用axios或者类似fetch库，方便易用，但在CORS跨域资源获取中遇到的问题不少。 axios 使用省略…文档 什么情况下需要 CORS ？在下列场景中使用跨域 HTTP 请求： 由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。 Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。 WebGL 贴图 使用 drawImage 将 Images/video 画面绘制到 canvas 这次说的是第一种 XMLHttpRequest 发起的跨域 HTTP 请求。 大家可能会认为，项目中客户端无非是发起get、post请求，是否允许客户端访问，是服务器端要控制的，只要服务器响应头设置 ‘Access-Control-Allow-Origin’:’*’ //所有客户端‘Access-Control-Allow-Origin’:’请求Origin值’ //允许特定客户端 其次，服务器响应对应个get、post请求类型和路径，这样就OK了。 真的OK吗?如果是OK的，说明应用场景叫简单；属于简单请求。 简单请求某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”： 使用下列方法之一： GET HEAD POST Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type （需要注意额外的限制） DPR Downlink Save-Data Viewport-Width Width Content-Type 的值仅限于下列三者之一： text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 满足以上条件时，是简单请求，浏览器发送一次请求。 预检请求与简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。 在破坏掉简单请求规则后，浏览器首先发起一个method=OPTIONS 的请求，询问服务器是否可以跨域等要求(跨域、方法、自定义头信息等特殊要求)，不满足则直接拒绝；如果同意时，则响应，并且响应头 新增 如下两个字段12Access-Control-Allow-Methods&apos; // 服务器所支持的请求方法Access-Control-Allow-Headers&apos; // 浏览器自定义的头部 加入原有请求是POST方式，在获的允许到，浏览器会再次发送一次POST请求； 举个生活中的简单例子，现在小区周边的学校晚上都开放了，允许居民健身运动；比如春节期间，你晚上去学校了，到了门口一看，门卫说假期不对外开放，结果是不能进去健身了，而且白跑一趟，浪费时间和精力，这相当于一个简单请求；优化：去之前先打个电话，询问下是否可以健身，可以就去，不可以就去做其他事情，是不是很省事情呀，这个过程就是 OPTIONS 请求。 继续故事，第二天，你仍然事先打电话询问，然后再做下一步打算，去或不去；时间多了，你会烦死的，门卫也会烦死的；优化：多次电话询问后，门卫聪明了，这次他告诉你，接下来7天内每天都开放，这样你在最近7天肯定不会在打电话先咨询了；这个时间就是 OPTIONS 请求响应头Access-Control-Max-Age中设置缓存时间。 从中我们应该能感知到，在非简单请求时，浏览器认为是个重请求，超出了服务器默认设置，浏览器会认为可能会被服务器拒绝掉，因此携带大量数据去请求可能白跑一趟，做了优化，先预检请求,看下服务器是否允许，允许多久等，对于跨域请求性能有很大提高； 当请求满足下述任一条件时，即应首先发送预检请求： 使用了下面任一 HTTP 方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为： Accept Accept-Language Content-Language Content-Type (but note the additional requirements below) DPR Downlink Save-Data Viewport-Width Width Content-Type 的值不属于下列之一: application/x-www-form-urlencoded multipart/form-data text/plain 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。 请求中使用了ReadableStream对象。 服务器改造大部分情况下，我们设置了跨域，但忽略了对 OPTIONS 响应的处理，最终没有处理或者返回404，错误路径； 以下是 koa.js 简单处理，OPTIONS 请求返回204，允许访问，当然你可以针对路径设置 OPTIONS；1234567891011121314151617181920/** * [cros跨域处理] * @param &#123;[type]&#125; async (ctx, next [description] * @return &#123;[type]&#125; [description] */app.use(async (ctx, next) =&gt; &#123; ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); if (ctx.method === &apos;OPTIONS&apos;) &#123; // 请求method =options，是预检请求 // 此时做些简单，处理，如果希望访问则如下，不希望时， // 设置缓存时间，下次 OPTIONS 请求不会再次发起，直接使用真实的请求如GET、POST、PUT // ctx.set(&quot;Access-Control-Max-Age&quot;, 86400000); ctx.set(&apos;Access-Control-Allow-Methods&apos;, &apos;OPTIONS, GET, PUT, POST, DELETE&apos;); ctx.set(&apos;Access-Control-Allow-Headers&apos;, ctx.header[&apos;access-control-request-headers&apos;]); // 发回204状态码，数据是空 ctx.response.status = 204; &#125; else &#123; await next(); &#125;&#125;); 参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS","categories":[],"tags":[]},{"title":"性能优化","slug":"performance","date":"2017-04-23T02:35:53.000Z","updated":"2018-12-01T09:44:23.000Z","comments":true,"path":"2017/04/23/performance/","link":"","permalink":"https://kangning1206.github.io/2017/04/23/performance/","excerpt":"","text":"浏览器 缓存，如localStorage 预加载 利用link rel=”preload” 提前下载，但并不会阻塞页面渲染；as属性 设置加载的媒体类型；12&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt; 图片合并 资源加载顺序css 在 head区域加载,js在尾部加载；如果js页面与渲染无关系，可以设置异步； 开发PWA 单页面应用；减少页面跳转和资源请求； 服务器 cors缓存，比如options 请设置 头 Access-Control-Max-Age； 升级到http2协议 合理的缓存设置 gzip 文件压缩，css、js资源 避免重定向，重定向的后果是客户端需要发起多次请求后才获取到真正资源； 网络 cors跨域请求 网站资源预加载，在html中设置，包括dns-prefetch DNS;pre-loader css,js; 网络资源文件大小控制，比如压缩； 减少请求次数 JavaScript DOM 增删改， 操作次数，最好一次性触发页面reflow、repaint； 减少作用域链查找，需要频繁访问的变量，最好在本作用域内可以找到； 精简css文件，混淆、压缩；工程化打包工具会处理；source-map文件在外部或者不输出； 减小js文件：如删除js文件中重复代码，提取公共组件或函数； ajax请求，首选get,会被浏览器缓存，post浏览器不缓存； css css选择器 深度不宜多；css 引擎是从右往左的，左边不要添加太多限定词； css 动画优先于js； 勿用css表达式；","categories":[],"tags":[]},{"title":"cookie","slug":"cookie","date":"2016-12-28T10:35:53.000Z","updated":"2018-12-28T11:07:21.000Z","comments":true,"path":"2016/12/28/cookie/","link":"","permalink":"https://kangning1206.github.io/2016/12/28/cookie/","excerpt":"","text":"cookie安全 设置 secure 属性；仅允许 cookie 在https 协议下在服务器和客户端之间传输； 设置 HttpOnly 属性；禁止 JavaScript 读取，同时可以防止 xss 攻击； 敏感信息不再 cookie 中存储； 类似论坛、发帖、评论，过滤掉非法信息，避免注入代码； cookie 和 session 双重验证； 二次验证码 优化网站，提升规则策略，使攻击者攻击成本增加；","categories":[],"tags":[]},{"title":"xss 攻击与防御","slug":"xss","date":"2016-08-15T00:31:02.000Z","updated":"2018-12-01T09:45:00.000Z","comments":true,"path":"2016/08/15/xss/","link":"","permalink":"https://kangning1206.github.io/2016/08/15/xss/","excerpt":"","text":"XSS定义跨站脚本攻击Cross-site scripting (XSS)是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。 简单点：用户访问网站时，浏览器上执行了不是网站作者意图的代码，而是一个捣乱者的意图，不受控作者控制了，那么捣乱者就可能会窃取访问者的信息； 危害 窃取用户的cookie，localStorage; 将用户重定向到钓鱼网站，比如跳转到一个似真银行网站，当你输入用户名和密码时登录时，实际是在钓鱼网站操作。 破坏网站内容和结构； 注入广告、垃圾信息； 存储型 XSS如果您的网站是与用户有数据交互的，比如论坛，基本流程是用户发帖子、帖子被其他用户浏览，帖子内容网站管理员不可以扭曲，需保证一致性，借此，恶意发帖人会注入一段javascript脚本，然后上传到服务器，最后帖子被查看时，服务器原样吐出来，问题是吐出来时已经不是网站作者的原有意图了； 防御方法 第一种：replace 内容存储前处理，在写入数据库时，过滤掉不安全内容，然后在存储；特点：用户编辑时，已经不是当初内容了，而且服务器上也找不到原来内容； 第二种：filter 响应时，过滤掉不安全内容，只输出安全内容，像php中有过滤规定标签的函数可以处理；特点：用户编辑时，已经不是当初内容了，但服务器上有； 第三种，在浏览器端展现时，htmlEncode 编码，使其不可以在浏览器上执行；特点：用户编辑时，看到的就是原有内容； 从内容一致性原则看，第三种最好，文本输入框输入不做限制，也许用户输入标签和脚本 本来就是他的目的，比如技术帖子，正常的需求。但前段工程师在输出页面时必须 htmlEncode 编码输出页面，不给不法者运行环境； 三种各有特点，使用场景不一样，比如第一种，业务需求是不允许输入特殊字符，服务器在存储前做校验，不通过时告知用户，只有符合规则了才给予了保存。","categories":[],"tags":[]},{"title":"浏览器的DOM","slug":"dom","date":"2016-06-20T02:58:22.000Z","updated":"2018-12-01T10:14:25.000Z","comments":true,"path":"2016/06/20/dom/","link":"","permalink":"https://kangning1206.github.io/2016/06/20/dom/","excerpt":"","text":"DOM解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是“Document”对象。 DOM 与标记之间几乎是一一对应的关系。比如下面这段标记 12345678&lt;html&gt; &lt;body&gt; &lt;p&gt; Hello World &lt;/p&gt; &lt;div&gt; &lt;img src=\"example.png\"/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 可翻译成如下的 DOM 树： 1234Object.prototype.toString.call(document.children[0])// 返回 \"[object HTMLHtmlElement]\"，证明了 document的第一个子元素是 html，当然也只有一个；document.children.length// 1 呈现树和 DOM 树的关系呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示） webkit 流程 css的阻塞测试一如下测试中，文件 http://127.0.0.1:5000/css 设置了延迟，其表现： 在等待过程中，后边的css文件gitbook-min.css 也发出了请求，且下载成功了，说明css不会阻塞其他css文件下载； 但页面上没有可视内容，是一片空白； 另外元素 dom 通过 document.getElementById(‘out’) 查看是存在的； 结论：css 不会阻塞其他css下载；不会阻塞dom树构建；但会影响页面渲染；也就是说，页面渲染需要dom tree 和 css rules都准备完成，然后在合并为render tree，最后渲染；卡壳等待原因是在css rules处； 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://127.0.0.1:5000/css\"&gt;&lt;style type=\"text/css\"&gt; body&#123; background-color: yellow; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"out\"&gt;dom&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试二以下：在头部插入脚本时，在http://127.0.0.1:5000/css 请求过程中，js未执行，dom未渲染； 结论：css 在请求期间，不会阻塞其他css样式文件，但会阻js；注意加载位置顺序： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://127.0.0.1:5000/css\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://a.apebook.org/gitbook-min.css\"&gt;&lt;script type=\"text/javascript\"&gt;alert(1)&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://www.bootcss.com/assets/css/site.min.css?1542483686613\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"out\"&gt;dom&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试三以下：css延迟脚本在页面底部，并且设置body是黄色，在执行等待期间，其他css文件已下载，页面是白屏等待，并未看到黄色背景，此时body,div等dom元素都是存在的，页面仍未看到效果； 结论：css文件无论在什么位置，只要没加载完成，都会阻塞dom的渲染; 在渲染之前， Style Rules必须准备就绪，在未就绪前，渲染和dom 都是无意义的；但是浏览器也做了超时控制，不可能无限制等待，因为没有css时，简单的dom也是可用的，因此当外部css文件超时后，就被忽略掉，使用了页面黄色背景，并且完成页面渲染； 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://a.apebook.org/gitbook-min.css\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://www.bootcss.com/assets/css/site.min.css?1542483686613\"&gt;&lt;style type=\"text/css\"&gt; body&#123; background-color: yellow; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"out\" style=\"color: blue;\"&gt;dom&lt;/div&gt; &lt;input type=\"\" name=\"\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://127.0.0.1:5000/css\"&gt;&lt;/body&gt;&lt;/html&gt; 测试四css 延迟100秒，js延迟5秒； 在css等待响应过程中；js在5后下载成功； 获取dom不存在，此时页面body元素都看不到； js文件下载后，但未被执行； 分析下浏览器设计思路： 浏览器在请求下载 css和js外部文件，是不会相互阻塞的下载，阻塞的是执行和使用资源； 资源的使用是相互依赖的； js准备就绪，执行的前提是dom存在； 若需要dom，则css文件需存在； 设想：css文件在等待下载中，js文件已经准备好了，如果允许dom准备，那么js文件执行，执行后，此时css文件仍然未下载完成，页面还是看不到，那么执行这个js任务有什么意义；执行js文件后，如果css文件下载完成，页面渲染，试想看到的页面是js的目的吗，加入js更改了背景颜色，后来css又更改了背景颜色，岂不是乱套了。记住，js修改页面时，允许是页面已经就绪，否则混乱了； 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://127.0.0.1:5000/css2\"&gt;&lt;script type=\"text/javascript\" src=\"http://127.0.0.1:5000/js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"out\" style=\"color:blue;\"&gt;dom&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试五css 延迟100秒，js延迟5秒； 页面在css、js等待下载过程中，dom很快生成了，但页面是空白的，因为还没有渲染； 5秒后，js文件下载完成，css还在等待下载中，但js未执行，即使dom存在了，因为css文件在前边，如果此时js执行了，后边css文件又影响了页面渲染，那么js执行的效果未必是开发者可以控制的或开发者的目的； 结论：页面在等待下载css过程中，在生成新的渲染之前，是不允许执行js的，必须等待生成新的渲染上下文后，再执行js； 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://127.0.0.1:5000/css2&quot;&gt;&lt;style type=&quot;text/css&quot;&gt; body&#123; background-color: yellow; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;out&quot; style=&quot;color:blue;&quot;&gt;dom&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1:5000/js&quot;&gt;&lt;/script&gt;&lt;/html&gt; js 阻塞js延迟10秒；css 延迟3秒， 如下测试中，文件 http://127.0.0.1:5000/js 设置了延迟返回，是个js文件，有个alert(1)片段； 在js和css都未完成下载时，dom不存在； 在js等待下载，css已下载，dom仍然不存在； js下载完成，执行了alert(1)，但为关闭，也就是说脚本执行了，但未执行完之前，dom仍然不存在； js完成执行后，生成了dom ,渲染了页面； 结论：js文件会阻塞后续js文件执行和dom生成,为了尽快渲染dom，应该js文件在页面底部加载，头部禁止，除非业务必须使用的资源脚本；js文件是同步执行，必须执行完成一个后，才能执行下一个js或页面渲染； 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"http://127.0.0.1:5000/js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://127.0.0.1:5000/css2\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"out\"&gt;dom&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器js和js位置位置对执行顺序的影响 css规则：css在文件头部，目的是准备就绪css rules，规则未准备好之前页面不渲染，禁止用户看页面，防止页面跳动; 页面渲染：执行body区域，生成dom tree,同时与css合并生成render tree,最终渲染完成，用户看到初始页面； 执行脚本：顺序执行脚本任务，动态更改css和dom，重新完成一次渲染； 以上是用户体验最好的加载顺序；资源请求下载是异步的，不会被阻塞；js和css相互阻塞的是执行、执行、执行；","categories":[],"tags":[]},{"title":"前端规范","slug":"standard","date":"2016-01-03T02:22:22.000Z","updated":"2019-01-03T03:49:50.000Z","comments":true,"path":"2016/01/03/standard/","link":"","permalink":"https://kangning1206.github.io/2016/01/03/standard/","excerpt":"","text":"文件规范 资源存放位置有分类， html, css, js, images文件均归档至约定的目录中; html文件命名: 英文命名, 后缀.html或.htm. 同时将统一页面文件放于同目录中, 以方便后端添加功能时查找对应页面; css文件命名: 英文命名, 后缀.css. 共用base.css, 首页index.css, 其他页面依实际模块需求命名.; Js文件命名: 英文命名, 后缀.js. 共用common.js, 其他依实际模块需求命名。 文件编码 utf-8; 基本原则结构、样式、行为分离尽量确保文档和模板只包含 HTML 结构，样式都放到样式表里，行为都放到脚本里。也就是说 html、css、js文件做好自己的职责，不要混合编写代码，目的就是为了清晰、方便控制； 注释规范html标签 自闭合标签，无需关闭，如 img input br hr 尽量减少标签数量 属性 双引号 属性顺序，id、class、name、data-xxx、src、for、type、href、title、alt; bool属性不用设值 语义化没有 CSS 的 HTML 是一个语义系统而不是 UI 系统，因此在无css的情况下，要确保信息可阅读。同时语义化有助于SEO以及他人了解开发者意图； head 文档类型 &lt;!DOCTYPE html&gt; IE 兼容模式&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;,优先chrome，否则IE最新版本 viewport SEO，keywords、description的描述 定义favicon 确保不出现404；&lt;link rel=&quot;shortcut icon&quot; href=&quot;path/to/favicon.ico&quot;&gt; 或者根目录携带favicon.ico； 加载css； js文件视情况选择加载，非必须的此处不加载，js执行和页面渲染时互斥的，防止阻塞。 其他有意义meta; 总之，项目中可以针对pc和移动端，定义两套HEAD魔板； css性能优化 慎用高消耗样式，主要集中在图形类 避免重排，常见的重排元素: width height padding margin display border-width position top left right bottom font-size float text-align overflow-y font-weight overflow font-family line-height vertical-align clear white-space min-height display 属性会影响页面的渲染，请合理使用。简单原则是设置好其他属性，最后再设置display; display: inline后不应该再使用 width、height、margin、padding 以及 float； display: inline-block 后不应该再使用 float； display: block 后不应该再使用 vertical-align； display: table-* 后不应该再使用 margin 或者 float； 避免滥用 float,float计算量较大 利用硬件能力； 例如：使用 translate3d 右移 500px 的动画流畅度要明显优于直接使用 left： 123456789101112131415161718/*.ball-1 &#123; transition: -webkit-transform .5s ease; -webkit-transform: translate3d(0, 0, 0);&#125;.ball-1.slidein&#123; -webkit-transform: translate3d(500px, 0, 0);&#125;.ball-2 &#123; transition: left .5s ease; left：0;&#125;.ball-2.slidein &#123; left：500px;&#125;*/ 提升css选择器性能 css 是从右到左解析；原则是层次少、不冗余，降低css过滤和检索时间； 避免使用通用选择器 12.content * &#123;color: red;&#125; 浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况。 避免使用标签或 class 选择器限制 id 选择器 1234/* Not recommended */button#backButton &#123;…&#125;/* Recommended */#newMenuIcon &#123;…&#125; 解释：从右侧先找到 #backButton，在判断是否是button元素，两个步骤，#id已表明是唯一的，在此限定规则多此一举； 避免使用标签限制 class 选择器 123456/* Not recommended */treecell.indented &#123;…&#125;/* Recommended */.treecell-indented &#123;…&#125;/* Much to recommended */.hierarchy-deep &#123;…&#125; 避免使用子选择器 123456/* Not recommended */treehead treerow treecell &#123;…&#125;/* Recommended */treehead &gt; treerow &gt; treecell &#123;…&#125;/* Much to recommended */.treecell-header &#123;…&#125; 多用css继承特性 利用继承特性，无需给子元素设置样式； 1234/* Not recommended */#bookmarkMenuItem &gt; .menu-left &#123; list-style-image: url(blah) &#125;/* Recommended */#bookmarkMenuItem &#123; list-style-image: url(blah) &#125; JavaScript略：可以引入Eslint插件，使用airbnb公司规则，非常严格；","categories":[],"tags":[]},{"title":"GC-垃圾回收","slug":"GC","date":"2015-08-10T03:37:28.000Z","updated":"2018-12-10T04:08:45.000Z","comments":true,"path":"2015/08/10/GC/","link":"","permalink":"https://kangning1206.github.io/2015/08/10/GC/","excerpt":"","text":"内存生命周期不管什么程序语言，内存生命周期基本是一致的： 值得初始化，分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放\\归还 垃圾回收内容 “不在需要”时，将被回收，难度是如何界定是否不需要；JavaScript 引擎有两种解决方案； 引用计数此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 它是最初的算法，存在一定的缺陷（循环引用），已经过时；2012年以后，主流浏览器使用了标记-清除算法； 标记-清除这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。 算法原理标记清除算法从名称上看，可以拆分为两部分:标记(mark)和清除(sweep)。 此算法可以分为两个阶段，一个是标记阶段，一个是清除阶段，下面就分别做一下介绍。 标记阶段: 在此阶段，垃圾回收器会从mutator（应用程序）根对象开始遍历。 每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。 清除阶段: 在此阶段中，垃圾回收器，会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。 图示如下: 在标记阶段，从跟对想1可以访问到B，从B又可以访问到E，那么B和E都是可到达对象，同样的道理，F、G、J和K都是可到达对象。在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收。 标记位置是在堆内存上打标记； 执行 var obj = {a:’some’}；后，给obj分配栈地址，同时给内容{}在堆内设置空间存储内容； 执行 obj = null后，栈和堆的关系被释放，也就是说内容堆可能会出现游离状态，没有被任何对象给引用； GC 定时扫描 window下对象，只给能被引用到的堆做标记； 标记完成后，停止执行程序或者锁住，清除堆中未标记，释放空间； GC回收动作完成后，应用程序继续执行； 过一段时间，GC再去扫描window，在堆中重新标记； 特别说明:在垃圾回收阶段，应用程序的执行会暂停，等待回收执行完毕后，再恢复程序的执行。 参考：[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management]","categories":[],"tags":[]},{"title":"css","slug":"css","date":"2015-01-30T05:44:26.000Z","updated":"2018-12-01T09:43:34.000Z","comments":true,"path":"2015/01/30/css/","link":"","permalink":"https://kangning1206.github.io/2015/01/30/css/","excerpt":"","text":"CSS 实际上如何工作？当浏览器显示文档时，它必须将文档的内容与其样式信息结合。它分两个阶段处理文档： 浏览器将 HTML 和 CSS 转化成 DOM （文档对象模型）。DOM在计算机内存中表示文档。它把文档内容和其样式结合在一起。浏览器显示 DOM 的内容。 如何将你的 CSS 应用到你的 HTML 上 外部样式表 内部样式表 内联样式 CSS 声明由于 属性名和属性值 结对构成； css 选择器分类 简单选择器（Simple selectors）：通过元素类型、class 或 id 匹配一个或多个元素。 属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。 伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。 伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。 多重选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。 简单选择器伪类伪类不是选择元素，而是元素的某些部分，或仅在某些特定上下文中存在的元素。它们有两种主要类型 ： 伪类和伪元素。 一个 CSS 伪类（pseudo-class） 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。 12345678910111213141516171819202122232425262728293031323334353637383940:active:any:checked:default:dir():disabled:empty:enabled:first:first-child:first-of-type:fullscreen:focus:hover:indeterminate:in-range:invalid:lang():last-child:last-of-type:left:link:not():nth-child():nth-last-child():nth-last-of-type():nth-of-type():only-child:only-of-type:optional:out-of-range:read-only:read-write:required:right:root:scope:target:valid:visited 伪元素伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::)， 同样是添加到选择器后面去选择某个元素的某个部分。 我最熟悉的清除浮动 .cleanfix，就是利用了伪元素，给其设置样式和内容以此影响浮动；123456::after::before::first-letter::first-line::selection::backdrop 组合选择器 名称 组合器 选择 选择器组 A,B 匹配满足A（和/或）B的任意元素 后代选择器 A B 匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点） 子选择器 A &gt; B 匹配B元素，满足条件：B是A的直接子节点 相邻兄弟选择器 A + B 匹配B元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面） 通用兄弟选择器 A ~ B 匹配B元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A） 颜色颜色是由 Red、Green、Blue三个颜色调和，每个颜色256种 名称：如 red 16进制 如 #ffff00,其中两个表示一个颜色通道 RGB,如 rgb(255,0,0);, rbg是个函数，会帮我们计算，差别是每个是10进制 HSL 支持度比RGB稍微差一点的是HSL（旧版本的IE浏览器不支持），这是在众多开发者对其产生兴趣之后才实现的——hsl()函数接受三个表示色调、饱和度以及明度的参数，使用与上述三种不同的方式来区分大约1670万种颜色： 色调：颜色的底色调。这个值在0到360之间，表示色轮的角度。 饱和度：饱和度是多少？这需要一个从0-100%的值，其中0是没有颜色（它将显示为灰色），100%是全彩色饱和度。 明度：颜色有多亮或明亮？这需要一个从0-100%的值，其中0是无光（它会出现全黑的），100%是充满光的（它会出现全白）。 RGBA 和 HSLA 是RGB、HSL的对应透明度transparency函数； 颜色数值颜色，在chrome开发者工具，颜色面板可以转化查看;css更多函数值另查手册； RGBA透明度与opacity属性差别，opacity除了影响自身透明，还影响了子节点透明度，rgba只设置了自己； 选择器计算规则一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字： 千位：如果声明是在style 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。 百位：在整个选择器中每包含一个ID选择器就在该列中加1分。 十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。 个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。 float 元素如何工作浮动元素会脱离正常的文档布局流，并吸附到其父容器的左边 flaot:left。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。 注意浮动内容仍然遵循盒子模型诸如外边距和边界。我们设置一下图片右侧的外边距就能阻止右侧的文字紧贴着图片。 12345678910111213141516171819202122232425/*.clearfix &#123; zoom: 1;&#125;.clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;*/.fn-clear &#123; zoom: 1&#125;.clearfix:after &#123; visibility: hidden; display: block; font-size: 0; height: 0; content: &quot; &quot;; clear: both&#125; 外边距叠加如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫外边距折叠, 我们之前也遇到过。","categories":[],"tags":[]}]}