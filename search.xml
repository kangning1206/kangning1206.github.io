<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>小程序码</title>
      <link href="/2019/01/08/mpcode/"/>
      <url>/2019/01/08/mpcode/</url>
      
        <content type="html"><![CDATA[<p>写在前边：</p><p>最近在看很火的小微信程序，使用微信扫描打开，在我们一般认识中，扫描一般是商品条形码、二维码？这种是什么码？叫什么名字呢？</p><p><img src="/img/Snip20190107_1.png" alt="小程序码"></p><p>问了群了，尽然也没人了解，看到过，就是不知道名字。尝试使用支付宝、淘宝扫描，没反应，说明识别不了。<br>当前微信是可以扫描的，但我行知道扫描的结果，当好在写微信小程序学习demo，介入扫描功能，打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;result&quot;: &quot;&quot;,</span><br><span class="line">    &quot;charSet&quot;: &quot;UTF-8&quot;,</span><br><span class="line">    &quot;errMsg&quot;: &quot;scanCode:ok&quot;,</span><br><span class="line">    &quot;scanType&quot;: &quot;WX_CODE&quot;,</span><br><span class="line">    &quot;rawData&quot;: &quot;azE7L356YU8rWi5MNGVAbU89QlpuNg==&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanType等于WX_CODE，如果是二维码是QR_CODE; 和明显是微信使用的特例，恰好第二天看到如下文章，原来可以称 <code>小程序码</code></p><blockquote><p>以下文章来源于：<a href="https://www.sohu.com/a/196399314_655055" target="_blank" rel="noopener">https://www.sohu.com/a/196399314_655055</a></p></blockquote><div><br>      <div class="text-title"><br>        <h1>小程序的那些事儿：你一定不知道，小程序码是这样绽放的<br>        </h1><br>    </div><br><article><br>      <p data-role="original-title" style="display:none">原标题：小程序的那些事儿：你一定不知道，小程序码是这样绽放的</p><br>            <p style="text-align: right;"><span style="font-size: 16px;">本文出自 Tencent CDC</span></p><br><p><span style="font-size: 16px;">腾讯 CDC 全称为「用户研究与体验设计中心」，是腾讯公司级设计团队，致力于提升腾讯产品的用户体验，探索互联网生态体验创新。</span></p><br><p><span style="font-size: 16px;">最近，我有幸代表团队参加了 HiFSD 第三届前端分享会「小程序专场」，为了避免与其它嘉宾「撞车」，我分享了一些跟「小程序码」相关的内容 。</span></p><br><p><span style="font-size: 16px;">分享会结束后，在同事的鼓励下，我把这次分享的内容进行了整理一下：</span></p><br><p style="text-align: center;"><img src="http://5b0988e595225.cdn.sohucs.com/images/20171005/74eb666424a0430a88e9edc88fa894ed.jpeg"></p><br><p><span style="font-size: 16px;"><strong><span>小程序码的出现</span></strong></span></p><br><p><span style="font-size: 16px;">2017 年 1 月 9 号，微信正式发布小程序，最开始只能通过微信「扫一扫」识别进入特定小程序。4 月 14 号，正式开放了「长按识别二维码」的功能，这意味着，用户使用小程序的便捷程度将大大提高。</span></p><br><p><span style="font-size: 16px;">小程序码虽然长得跟二维码截然不同，但二维码所有的功能，小程序码同样具备。</span></p><br><p><span style="font-size: 16px;">为什么微信要推出这样的异形二维码？小程序码背后又有何故事？</span></p><br><p><span style="font-size: 16px;">别着急，今天就来给大家讲讲小程序码背后的故事。</span></p><br><p><span style="font-size: 16px;"><strong><span>二维码 VS 小程序码</span></strong></span></p><br><p><span style="font-size: 16px;">第一次扫小程序码的时候，其实是抱着试一试的心态来的。</span></p><br><p><span style="font-size: 16px;">当时就在想，这么不像二维码的码真的能扫出来？结果一试还真可以！后面通过查找资料才发现，原来这种异形二维码并不是微信的首创，Facebook、Snap 等公司都已经推出过类似的异形码：</span></p><br><p style="text-align: center;"><img width="745" height="283" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/c77b725fb1754f919fb048f81516cae4.jpeg"></p><br><p><span style="font-size: 16px;">下面这个二维码通过图像处理和识别技术把传统二维码中近70%的色块抹掉，做成一种近乎无形的二维码。它是以色列一家创业公司（Visualead）的作品。</span></p><br><p style="text-align: center;"><img width="378" height="378" src="//5b0988e595225.cdn.sohucs.com/images/20171005/7275ae7bb47e46a092c8fa618d9beb14.jpeg"></p><br><p><span style="font-size: 16px;">阿里巴巴于2015年投资了这家公司，在旗下的网站、APP 以及云计算等产品中已经开始使用 相关技术。</span></p><br><p><span style="font-size: 16px;">此外还有很多充满想象力的「变脸二维码」（作者：笑脸兔）：</span></p><br><p><img width="625" height="663" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/a0f12ebe636c4d6294d1b6c36f05c36a.jpeg"></p><br><p><span style="font-size: 16px;">面对市面上这么多好玩又有趣的二维码，微信推出专属的小程序码，既意料之外，又情理之中。</span></p><br><p><span style="font-size: 16px;">如果上面的理由还没有说服到你，我们再从二维码和小程序码对比的角度，来看看小程序码有什么优点。</span></p><br><p><span><strong><span style="font-size: 16px;">传统二维码往往以有下几个缺点：</span></strong></span></p><br><blockquote><br> <p><span><strong><span style="font-size: 16px;">• </span></strong></span><span style="font-size: 16px;">扫码预期：每张二维码的背后可能代表一个文件，一个页面、又或者是一个应用</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>安全性：二维码由于其开放性，很容易成为木马病毒的温床，很多人会担心扫码之后可能</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>使自己的手机感染病毒而放弃扫码</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>品牌宣传：无法满足小程序的品牌宣传需求</span></p><br></blockquote><br><p><span><strong><span style="font-size: 16px;">小程序码的优点：</span></strong></span></p><br><blockquote><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>观赏性：小程序码与普通二维码相比，看起来更美观</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>品牌宣传：每个小程序码右下角都是固定的微信小程序 Logo，每见到一次小程序码大家就能多一次联想到微信小程序</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>高容错性：当一张二维码图片中间嵌有某些 Logo 图片时，其实相当于是把最中间部分有用的编码信息挖掉，再贴一张 Logo 图片上去。</span></p><br></blockquote><br><p><span style="font-size: 16px;">而小程序码不同，中间的 Logo 区并不包含数据编码的部分，因此小程序码拥有更高的容错性</span></p><br><p><span style="font-size: 16px;">很明显，小程序码是更好的选择：）</span></p><br><p><span style="font-size: 16px;"><strong><span>小程序码的绽放过程</span></strong></span></p><br><p><span style="font-size: 16px;">这是小程序码最初的设计稿雏形，可以看到的确是一朵花的形状，稍有不同的是这个雏形图中只有两个定位点。</span></p><br><p><span style="font-size: 16px;">而目前我们看到的小程序码，一共有3个定位点。</span></p><br><p style="text-align: center;"><img width="367" height="400" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/ffebcdf7bdac4938b37b69925750f341.jpeg"></p><br><p><span style="font-size: 16px;">这个是小程序码的规范设计稿：</span></p><br><p style="text-align: center;"><img width="372" height="368" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/c8dc5078d9974585830906e49edb74b9.jpeg"></p><br><p><span style="font-size: 16px;">目前小程序码一共支持 3 种容量，分别是 36 射线、54 射线和 72 射线。</span></p><br><p style="text-align: center;"><img width="652" height="216" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/423be40c64d8449098f7c604ec0099f9.jpeg"></p><br><p><span><strong><span style="font-size: 16px;">每个版本分别对应 L、M、Q、H 4种容错级别：</span></strong></span></p><br><blockquote><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>L 级容错的小程序码，大约 10% 的字码可被修正</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>M 级容错的小程序码，大约 15% 的字码可被修正</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>Q 级容错的小程序码，大约 25% 的字码可被修正</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>H 级容错的小程序码，大约 35% 的字码可被修正</span></p><br></blockquote><br><p><strong><span style="font-size: 16px;">这应该如何理解呢？</span></strong></p><br><p><span style="font-size: 16px;">例如 H 级容错的小程序码，大约 35 %的字码可被修正。这意味着在最理想情况下，当这个小程序码 35% 的面积被遮挡/损坏，扫码引擎还是能识别出这个小程序码承载的信息。</span></p><br><p><span style="font-size: 16px;">但是，这 35% 被破坏的面积，不能是定位图案和功能性数据，必须是纯编码区，而且错误的区域还要分布得刚刚好，条件是非常苛刻的。</span></p><br><p><span style="font-size: 16px;">所以，这里的百分数是一个非常理想的数据，实际测试的结果会比这个百分数稍微低一些。</span></p><br><p><span style="font-size: 16px;">不过现阶段，当我们通过官方 API 文档去请求一张小程序码图片时，暂时不用（或者说未能）指定期望生成的是哪种版本、哪个容错级别的小程序码，这些是微信后台会帮开发者自动选择的。</span></p><br><p><span style="font-size: 16px;">麻雀虽小，五脏俱全。</span></p><br><p><span style="font-size: 16px;">小程序码有两个 Logo 区域，分别是中间的自定义 Logo 区和右下角的官方 Logo 区，灰色的区域是小程序码的数据编码区，其它彩色区域是小程序码的功能性数据（主要包括版本、纠错等信息。至于具体如何对应，由于微信官方暂时尚未对外公开，所以这里也要先保密一下哦）</span></p><br><p style="text-align: center;"><img height="144" width="790" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/10ba4e9709a140c1aed8f3f04f3ccc28.png"></p><br><p><strong><span style="font-size: 16px;">小程序码这朵「菊花」是如织绽放的呢？主要要以下几个步骤：</span></strong></p><br><p><strong><span style="font-size: 16px;">1、定位点</span></strong></p><br><p><span style="font-size: 16px;">首先确定 3 个定位点和右下角的官方 logo 区，经过第一步小程序码的大小也随着确定。</span></p><br><p style="text-align: center;"><img width="276" height="280" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/7c3f50e211d345c29bce190552279ab4.jpeg"></p><br><p><strong><span style="font-size: 16px;">2、信息编码区</span></strong></p><br><p><span style="font-size: 16px;">编码的过程主要是把原始信息（例如某个小程序的首页）转化成计算机能识别的语言——二进制序列（例如 0110…110）的过程。</span></p><br><p><span style="font-size: 16px;">听起来是不是有点抽象？你可以这么理解，六个月大的婴儿吃不了大米，但是我们可以把大米砸碎研磨变成米浆米糊，这样他就可以食用消化的，原理是差不多的，大而化小 :）</span></p><br><p><img width="519" height="67" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/6259f9baeb1b40c1bfa7d53a8d3585da.png"></p><br><p><span style="font-size: 16px;">编码完的下一步是加纠错码。</span></p><br><p><span style="font-size: 16px;">这个过程有点复杂，这里我也尝试用大家能听懂的语言给大家解释一下。</span></p><br><p><span style="font-size: 16px;">假设桌子上先是放了 100 个生鸡蛋（代表上一步已经转换好的二进制序列），然后再加入120个熟鸡蛋（代表纠错码，具体个数就视纠错率而定了，这里只是一种假设）。</span></p><br><p><span style="font-size: 16px;">表面上看起来生鸡蛋和熟鸡蛋并没有太大的区别，但是其实还是有办法能辨别出来的。例如，生鸡蛋由于蛋黄悬浮到鸡蛋中间，重心不稳，无法旋转，而熟鸡蛋是可以旋转的。</span></p><br><p><span style="font-size: 16px;">经过纠错码这个步骤，数据量变大了（从生熟鸡蛋的例子来看，桌子上的鸡蛋由 100 个变为 220 个），而回到我们上一个步骤，相当于把二进制序列 0110…110 进行了扩展（假设原来 0 和 1 加起来一共有 170 位，经过纠错编码之后就变成了一共 400 位的 1010…101）。</span></p><br><p><img width="748" height="67" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/c63bdaf85fbc413fb89e42dd7b38176b.png"></p><br><p><span style="font-size: 16px;">这里需要补充说明的一点是，加纠错码这个阶段不只是让数据量简单地增大。</span></p><br><p><span style="font-size: 16px;">一旦小程序码的版本、纠错级别确定了，其对应的纠错码都是固定的了，这样解码阶段才能通过对应的规则去消除纠错码，把真正有用的数据保留下来（回到生熟鸡蛋的例子就是只留下生鸡蛋，而把熟鸡蛋排除掉）。</span></p><br><p><span style="font-size: 16px;">经过信息转换和纠错编码之后，我们得到一串最终的二维码序列，就可以把信息按一定的编码顺序填充到小程序码的编码区域（1对应的是黑色，0对应的是白色）。</span></p><br><p><span style="font-size: 16px;">填充之后我们发现小程序上花瓣看起来很不均匀，比如下图：</span></p><br><p><img width="728" height="281" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/30c3eeed30604e59ac9b60a7f502be6d.jpeg"></p><br><p><span style="font-size: 16px;">所以为了让小程序码的花瓣看起来更加均衡，需要再多做一步操作。</span></p><br><p><span style="font-size: 16px;">分隔线开始</span></p><br><p><span style="font-size: 16px;">在此之前，我们先来学习一下逻辑异或（XOR，符号是⊕ ）的基本知识，请看下面这个表格。</span></p><br><p><img width="209" height="158" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/22ab097035da458e8f6a6b65749fc445.png"></p><br><p><span style="font-size: 16px;">A ⊕ B ，当 AB 不等时值为1，AB 相等时值为0。A和同一个 B 经过两次异或操作，结果跟原码相同（A ⊕ B ⊕ B = A）。</span></p><br><p><img width="456" height="286" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/baf622c5ecce4e638af365bb3ca31f89.png"></p><br><p><span style="font-size: 16px;">分隔线结束</span></p><br><p><strong><span style="font-size: 16px;">3、掩码操作</span></strong></p><br><p><span style="font-size: 16px;">将小程序码跟 32 种掩膜（又称「mask」，可依照一定的规则生成）进行异或运算，最终选取效果最佳的作为最终的小程序码。</span></p><br><p><img width="582" height="525" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/03abeb4ec94a48ed89dd1e5179f14ae4.jpeg"></p><br><p><strong><span style="font-size: 16px;">4、功能性数据</span></strong></p><br><p><span style="font-size: 16px;">最后一步是填充功能性数据，最终效果如下：</span></p><br><p><img width="234" height="218" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/6f2d8643209b4e78b5574dc946b63c98.png"></p><br><p><span style="font-size: 16px;">至此，小程序码就完成了它的绽放过程 :）</span></p><br><p><span style="font-size: 16px;"><strong><span>获取小程序码</span></strong></span></p><br><p><span style="font-size: 16px;">根据小程序官方开发文档的说明，目前请求生成一个小程序码有两个接口（A 和 B），请求生成小程序二维码有一个接口（C），这三个接口有什么区别呢？</span></p><br><blockquote><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>数量限制：接口 A、C 生成的小程序码和二维码加起来不能超过 10w 个，接口 B 生成的小程序码则数量没有限制</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>时效性：接口 A、B、C 生成的小程序码/二维码永久有效</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>页面指定性：接口 A、C 生成的小程序码/二维码可以直接进入指定页面，而接口 B 生成的小程序码需要通过技术开发处理逻辑（通过参数 scene）后才能跳转到其它页面</span></p><br></blockquote><br><p><span style="font-size: 16px;">建议大家优先使用 B 接口去生成二维码，一方面是小程序码始终是比二维码可辨认性高，另一方面没有数量限制，而且技术处理也相对简单。</span></p><br><p><strong><span style="font-size: 16px;">关于小程序码的样式，现阶段我们主要可以定义以下方面的内容：</span></strong></p><br><blockquote><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>小程序码的尺寸</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>小程序码的射线颜色</span></p><br> <p><span style="font-size: 16px;"><strong><span style="font-size: 16px;">• </span></strong>自定义 Logo 区的图片</span></p><br></blockquote><br><p><span style="font-size: 16px;">由于目前我们只能定义小程序码的射线颜色，无法定义整个小程序码图片的背景颜色。所以在声明小程序码射线的颜色这一步，主要有两种思路：</span></p><br><p><span style="font-size: 16px;">通过设置 line_color 来决定小程序码射线的颜色，不过这个时候最好是确保射线跟背景色（白色）有一定的对比度，降低扫码成本</span></p><br><p><span style="font-size: 16px;">设置 auto_color 为 true（默认为 false），微信后台会智能根据中间 Logo区域的主色调来确定小程序码射线的颜色</span></p><br><p><span style="font-size: 16px;">小程序码识别过程跟小程序码的生成过程是反过来的，大家可以通过简单的流程图来感受一下。</span></p><br><p><img width="484" height="685" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/bab45f644edf462cbee2ff1d0a6c4891.jpeg"></p><br><p><span style="font-size: 16px;">虽然目前小程序暂时不支持直接分享到朋友圈，但是越来越多的小程序已经通过尝试将小程序码与业务功能相结合，生成一张可以在朋友圈传播的小程序码，方便其它用户通过长按识别小程序码直接（从朋友圈）进入相应的小程序。</span></p><br><p><img width="550" height="808" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/bfa4c3f973fa403e8eef342f146bbc1f.jpeg"></p><br><p><img width="251" height="595" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/a72c37c90a5044eba8c6b5881d95a6eb.jpeg"></p><br><p><img width="473" height="524" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/76a57a4a16d445b781f620890aa474ae.jpeg"></p><br><p><img width="472" height="524" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/70be87f934654a94a42797b02eb5152b.jpeg"></p><br><p><span style="font-size: 16px;">假设有人在朋友圈发送了一张包含小程序码（或二维码）的图片，你点击预览小图（这时称图片处于图片查看器中），这个时候也是可以长按识别的，那这个时候就是直接发图去识别！（但不一定是原图哦，这里的策略是非常非常多的，例如这张图片非常大，微信就会先做适当压缩再上传去识别的）</span></p><br><p><img width="472" height="528" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/b9610b0cc8454bf9a72dcdf83609667f.jpeg"></p><br><p><strong><span style="font-size: 16px;">参考文章和图片来源：</span></strong></p><br><blockquote><br> <p><span style="font-size: 16px;">小程序码相关介绍 —— by 微信团队</span></p><br> <p>《实践并解读最新的小程序码生成方式》<span style="font-size: 16px;">—— by 花叔</span></p><br> <p><span style="font-size: 16px;">《微信公众平台小程序开发档》</span></p><br></blockquote><br><span style="font-size: 16px;"><p><span style="font-size: 16px;"><strong><span>最后</span></strong></span></p><p><span style="font-size: 16px;">感谢大家阅读到最后，为了表达我的感激，我决定（再次）把研究过程中遇到过的最好看的小程序码的图片分享给大家 ：）</span></p><p><img width="308" height="308" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/00c8b787a75b470eb8276702afffe809.jpeg"></p><p><span style="font-size: 16px;">✲✲✲✲✲✲</span></p><p><span style="font-size: 16px;">感谢你的阅读，本文出自</span><span style="font-size: 16px;">Tencent CDC。</span></p><p style="text-align: center;"><span style="font-size: 16px;">一 END 一</span></p><p><img width="20px" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/d65e3b624b49433784b0ce86692a66cd.png"></p><p>据说，国庆不加班的都关注了这个 </p><p><img width="20px" src="http://5b0988e595225.cdn.sohucs.com/images/20171005/c874c74f1f6543b4b5c9488b67a79a67.png"><a href="https://www.sohu.com/?strategyid=00001&amp;spm=smpc.content.content.5.1546920476460cgQ7KXO" target="_blank" title="点击进入搜狐首页" id="backsohucom" style="white-space: nowrap;" data-spm-data="5"><span class="backword"><i class="backsohu"></i>返回搜狐，查看更多</span></a></p></span>      <p data-role="editor-name">责任编辑：<span></span></p><br></article><br></div>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>面试题</title>
      <link href="/2018/12/22/interview/"/>
      <url>/2018/12/22/interview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：面试题目，解决方法，我从招聘方角度，总结考点并且给出方法；</p></blockquote><h2 id="javascipt"><a href="#javascipt" class="headerlink" title="javascipt"></a>javascipt</h2><ul><li>查找一个字符串中，出现次数最多的字符以及次数</li></ul><p>考点：去重，比大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [maxCountChar 查找一个字符串中，出现次数最多的字符以及次数]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; str [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;     [返回结果对象，&#123;name,count&#125; 包括最大字符和次数]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxCountChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用对象属性不可以重复特点，不存在则为1，存在则++;</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = str[i];</span><br><span class="line">    <span class="keyword">if</span> (obj[key]) &#123;</span><br><span class="line">      obj[key]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化字符是空，次数0;</span></span><br><span class="line">  <span class="keyword">let</span> maxStr = &#123;</span><br><span class="line">    name: <span class="string">''</span>,</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找最大的数字</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[key] &gt; maxStr.count) &#123;</span><br><span class="line">      maxStr.name = key;</span><br><span class="line">      maxStr.count = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(maxCountChar('1a1ba2ca'));</span></span><br><span class="line"><span class="comment">// &#123;name: "a", count: 3&#125;</span></span><br></pre></td></tr></table></figure><ul><li>数组去重</li></ul><p>考点：ES6 Set 集合不允许重复对象，或者使用对象属性不重复特点。<br>常规新的数据循环比对不适合；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">34</span>,<span class="number">1</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// newArr是无重复数组；</span></span><br></pre></td></tr></table></figure><ul><li>返回结果</li></ul><p>考点：delete 操作符, 删除对象的某个属性，但并不是任意属性都能删除,只有enumerable的属性才可以移除；</p><p>let 变量不可以被移除；</p><p>语法，对于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete object.property</span><br><span class="line">delete object[&apos;property&apos;]</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">delete</span> x;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)(<span class="number">9</span> - <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p>控制台打印2；</p><ul><li><p>预编译</p><p>记住四步，函数内同名变量、函数名、变量提升等问题都可解释；</p><ol><li>创建AO对象；</li><li>找形参和变量声明，将变量和形参作为AO属性名称，值为undefined;</li><li>将实参和形参值统一，即给形参赋值；</li><li>在函数体内找函数声明，值赋予函数体;</li></ol></li></ul><p>第一题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>第一步: 创建<br>函数foo的AO:<br>{</p><p>}</p><p>第二部：</p><p>AO:{<br>  x:undefined      //此处x是形参声明<br>}</p><p>第三部：</p><p>AO:{<br>  x:undefined      //此处x是变量声明，覆盖了前者同名<br>}</p><p>第四部：</p><p>将实参合形参统一，给AO.x赋值20；</p><p>第五部：</p><p>打印x,此时是20；<br>给AO.x赋值10；<br>打印x,此时是10；</p><p>第二题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>第一步: 创建<br>函数foo的AO:<br>{</p><p>}</p><p>第二部：</p><p>AO:{<br>  x:undefined      //此处x是形参声明<br>}</p><p>第三部：</p><p>AO:{<br>  x:undefined      //此处x是函数内声明，覆盖了前者同名<br>}</p><p>第四部：</p><p>将实参合形参统一，给AO.x赋值20；</p><p>第五部：</p><p>AO:{<br>  x:function(){}      //此处x是函数声明，覆盖了前者同名<br>}</p><p>第六步：</p><p>打印x,此时AO.x 是函数function(){},输出<code>f x(){}</code><br>给AO.x赋值10；<br>打印x,此时是10；</p><ul><li>foo.x 值是什么？</li></ul><p>考点：引用赋值、变量赋值引用类型，连续等号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line">foo.x = foo = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>返回undefined;</p><p>分析：</p><p>第一行和第二行 foo和bar指向同一个引用地址；</p><p>第三行，同时给foo.x和foo设置值{n: 2}，foo.x指向的引用等于bar.x,值是{n:2},变量foo重新设置引用{n:2}</p><p>结果是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bar= &#123;</span><br><span class="line">    n: <span class="number">1</span>,</span><br><span class="line">    x: &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">foo = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// foo ===bar.x 返回true，两个指向同一个引用</span></span><br></pre></td></tr></table></figure></p><ul><li>打印结果</li></ul><p>考点：同步异步，Javascript是单线程，异步任务采用队列方式，空闲时再执行队列；<br><a href="https://www.jianshu.com/p/92f4506a28d0" target="_blank" rel="noopener">推荐文章</a></p><p>难点：setTimeout和Promise的优先级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// one four three two</span><br><span class="line"></span><br><span class="line">console.log(&apos;one&apos;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&apos;two&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">Promise.resolve().then(function() &#123;</span><br><span class="line">  console.log(&apos;three&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;four&apos;);</span><br></pre></td></tr></table></figure><ul><li>打印结果</li></ul><p>考点：await，await会暂停当前async函数的执行，等待后面的<code>Promise</code>的计算结果返回以后再继续执行当前的async函数。<br>并不是等待所有，只等待<code>Promise</code>类型；</p><p>Promise和async/await 适合大量连续（顺序）执行异步操作；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">async function async1() &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;script start&quot;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&quot;settimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">async1();</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure><p>结果：</p><p>script start<br>async1 start<br>async2<br>promise1<br>script end<br>promise2<br>async1 end<br>settimeout</p><blockquote><p>在输出 async2后，等待后边promise,所以输出promise1</p></blockquote><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li>什么是doctype？</li></ul><p>doctype 是文档类型；声明文档类型是必要的，主要目的是防止浏览器在渲染文档时，切换到“怪异模式(兼容模式)”；<br>明确的设置doctype，确保浏览器按照最佳的规范进行渲染；</p><blockquote><p>同一个类型浏览器，厂家为了兼容性，会有多个或兼容的方案来渲染页面；通知设置doctype来选择渲染引擎；</p></blockquote><ul><li><p>data attributes有什么好处？</p><ul><li>扩展了标签属性，允许在元素上存储数据，扩张性强；</li><li>语法简单，html标签属性中，以<code>data-</code>开头的属性是数据属性；</li><li>JavaScript 可访问，使用dom节点上dataset属性集访问；</li><li>css也可以访问。</li></ul></li></ul><ul><li><p>Describe the difference between <script>, <script async> and <script defer>.</p><ul><li>async 字面量即异步的，js执行是同步的阻塞的，增加此属性后，顺序被调整；该属性需要src外部脚本，对内联脚本无效；</li><li>defer 这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。</li><li>crossorigin=”anonymous” 请求头中设置Origin 属性；cors检查时使用；</li></ul></li></ul><ul><li>Why is it generally a good idea to position CSS <link>s between <head></head> and JS <script>s just before </body>? Do you know any exceptions?</li></ul><p>浏览器引擎原理讲起；</p><p>dom渲染和js执行是互斥的，不可能一遍渲染一遍执行js，不符合常理，因此js执行过程中，会停止dom渲染，即所谓的阻塞；那么我们将脚本沉入底部，dom和css完成结合后，在执行js动作；</p><p>css不会影响dom，但会影响渲染，如果css下载超时，则放弃此css节点文本；尽可能早的完成css 数的建立，放置在页面顶部是合理的；</p><ul><li>img标签的srcset属性？</li></ul><p>很少使用，但确实存在；</p><p>在srcset语法是以逗号分隔的一个或多个字符串列表表明一系列用户代理(一般是浏览器)使用的可能的图像。包括一个宽度描述符，一个图片地址；</p><p>根据浏览器窗口大小使用合适的尺寸图片；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"small.jpg "</span> <span class="attr">srcset</span>=<span class="string">"big.jpg 1440w, middle.jpg 800w, small.jpg 1x"</span> /&gt;</span></span><br></pre></td></tr></table></figure></script></p></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>prototype关系图</title>
      <link href="/2018/12/08/prototype-img/"/>
      <url>/2018/12/08/prototype-img/</url>
      
        <content type="html"><![CDATA[<p>js中对象、构造函数prototype、Function、Object关系。</p><embed src="/img/prototype.pdf" type="application/pdf" width="100%" height="600px">]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2018/12/07/designpattern-1/"/>
      <url>/2018/12/07/designpattern-1/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式，顾名思义，只创建一个实例，不允许创建多个，应用在拥有一个全局配置，比如系统配置文件；</p><p>更多应用场景 <a href="https://www.cnblogs.com/restartyang/articles/7770856.html" target="_blank" rel="noopener">https://www.cnblogs.com/restartyang/articles/7770856.html</a> 介绍的很多；</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>利用立即执行函数与闭包，返回一个对象，在闭包内控制实例化；</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>根据创建时机场景，分类以下两个</p><ul><li>赖汉式：需要时创建对象</li><li>饿汉式：一开始立刻创建对象</li></ul><h2 id="实现赖汉式"><a href="#实现赖汉式" class="headerlink" title="实现赖汉式"></a>实现赖汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 懒汉式，在需要使用时才会创建对象，不会提前创建</span><br><span class="line">var singleton = (function() &#123;</span><br><span class="line">  var instance = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // bengin: 单例实现类</span><br><span class="line">  // 单例模式只需要替换掉类实现，其他地方不用修改</span><br><span class="line">  /**</span><br><span class="line">   * [Singleton description]</span><br><span class="line">   * @param &#123;[type]&#125; options [description]</span><br><span class="line">   */</span><br><span class="line">  function Singleton(options) &#123;</span><br><span class="line">    options= options|| &#123;&#125;;</span><br><span class="line">    this.name = options.name || &apos;单例类属性&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  // 方法</span><br><span class="line">  Singleton.prototype.say = function() &#123;</span><br><span class="line">    console.log(&apos;我是单例模式=&apos;,this.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // end: 单例实现类</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    getInstance: function(options) &#123;</span><br><span class="line">      if (!instance) &#123;</span><br><span class="line">        // new 一个实例对象，此处是是使用new还是&#123;&#125;生成，看业务场景，简单的使用&#123;&#125;，需要继承时使用构造函数</span><br><span class="line">        instance = new Singleton(options);</span><br><span class="line">      &#125;</span><br><span class="line">      return instance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">var obj = singleton.getInstance(&#123;name:&apos;我是自定义&apos;&#125;);</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>deepclone</title>
      <link href="/2018/12/06/deepclone/"/>
      <url>/2018/12/06/deepclone/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 对象拷贝，浅拷贝比较见到那，for in 循环直接复制，但局限在值类型，对于数组和object 类型，则由于引用，并没有达到真正的拷贝；</p><p>思路</p><ol><li>定义一个deepclone 克隆函数，参数为克隆源头，帮助我们复制；</li><li>for in 源对象，如果直接属性是简单类型则，则直接赋值；否则递归，进一步分析此属性对应值，在进行for in；</li><li>返回拷贝后对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;aaa&apos;,</span><br><span class="line">  age: 18,</span><br><span class="line">  baby: false,</span><br><span class="line">  card: [&apos;master&apos;, &apos;visa&apos;, &#123; a: 1 &#125;],</span><br><span class="line">  wife: &#123;</span><br><span class="line">    name: &apos;lp&apos;,</span><br><span class="line">    son: &#123;</span><br><span class="line">      name: &apos;json&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  haha: /^Chapter [1-9][0-9]&#123;0,1&#125;$/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var nobj = deepclone(obj);</span><br><span class="line">console.log(&apos;origin =&apos;, obj);</span><br><span class="line">console.log(&apos; clone =&apos;, nobj);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * [deepclone 深度拷贝]</span><br><span class="line"> * @param  &#123;[type]&#125; origin [原始对象]</span><br><span class="line"> * @param  &#123;[type]&#125; target [新对象]</span><br><span class="line"> * @return &#123;[type]&#125;        [clone对象]</span><br><span class="line"> */</span><br><span class="line">function deepclone(origin, target) &#123;</span><br><span class="line">  // 容错，未定义 target 时，如果 orgin 是数组初始化为[],其他为&#123;&#125;</span><br><span class="line">  target = target || (isArray(origin) ? [] : &#123;&#125;);</span><br><span class="line">  // 执行拷贝，数据存储在 target</span><br><span class="line">  shallowCopy(origin);</span><br><span class="line">  /**</span><br><span class="line">   * [shallowCopy description]</span><br><span class="line">   * @param  &#123;[type]&#125; oriObj [description]</span><br><span class="line">   * @return &#123;[type]&#125;        [description]</span><br><span class="line">   */</span><br><span class="line">  function shallowCopy(oriObj) &#123;</span><br><span class="line">    for (var props in oriObj) &#123;</span><br><span class="line">      if (oriObj.hasOwnProperty(props)) &#123;</span><br><span class="line">        // 直接拷贝</span><br><span class="line">        var objType = getValueType(oriObj[props]);</span><br><span class="line">        if (objType == &apos;simple&apos;) &#123;</span><br><span class="line">          target[props] = oriObj[props];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 对象型，递归拷贝</span><br><span class="line">          target[props] = deepclone(oriObj[props], target[props]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * [getValueType 获取数据类型，分为两大类，simple类型直接使用，其他则递归]</span><br><span class="line">   * @param  &#123;[type]&#125; value [description]</span><br><span class="line">   * @return &#123;[type]&#125;       [description]</span><br><span class="line">   */</span><br><span class="line">  function getValueType(value) &#123;</span><br><span class="line">    var nameType = Object.prototype.toString.call(value);</span><br><span class="line">    var objType = &apos;simple&apos;;</span><br><span class="line">    switch (nameType) &#123;</span><br><span class="line">      case &apos;[object Number]&apos;:</span><br><span class="line">      case &apos;[object Boolean]&apos;:</span><br><span class="line">      case &apos;[object String]&apos;:</span><br><span class="line">      case &apos;[object Undefined]&apos;:</span><br><span class="line">      case &apos;[object Null]&apos;:</span><br><span class="line">      case &apos;[object RegExp]&apos;:</span><br><span class="line">        objType = &apos;simple&apos;;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        objType = &apos;object&apos;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return objType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function isArray(value) &#123;</span><br><span class="line">    return Object.prototype.toString.call(value) == &apos;[object Array]&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回拷贝对象</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>margin-collapsing</title>
      <link href="/2018/12/03/margin-collapsing/"/>
      <url>/2018/12/03/margin-collapsing/</url>
      
        <content type="html"><![CDATA[<p>margin collapsing</p><p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠（因为这里触发了 块格式化上下文 Block Formatting Context， BFC）。</p><figure style="text-align: center;"><br>  <img src="http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif" alt=""><br>    <figcaption>相邻元素</figcaption><br></figure><figure style="text-align: center;"><br>  <img src="http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif" alt=""><br>    <figcaption>父子元素</figcaption><br></figure><figure><br>    <figcaption></figcaption><br></figure><figure><br>    <figcaption></figcaption><br></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>css-box 盒子塌陷</title>
      <link href="/2018/12/03/css-box/"/>
      <url>/2018/12/03/css-box/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子塌陷"><a href="#盒子塌陷" class="headerlink" title="盒子塌陷"></a>盒子塌陷</h2><h3 id="什么是盒子塌陷"><a href="#什么是盒子塌陷" class="headerlink" title="什么是盒子塌陷"></a>什么是盒子塌陷</h3>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>htmlTempleate</title>
      <link href="/2018/12/01/htmlTempleate/"/>
      <url>/2018/12/01/htmlTempleate/</url>
      
        <content type="html"><![CDATA[<p>推荐一种 react 或者 vue 渲染 html页面模板，目的接在提高用户体验和性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文档类型默认Html5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据需要设置语言或者移除lang --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-cn"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 需要保留，页面编码格式，推荐uft-8 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 针对IE8设置，其他浏览器无效 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果IE有安装Google Chrome Frame，那么就走安装的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SEO: 页面关键词 keywords --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"your keywords"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SEO: 页面描述内容 description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"your description"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- viewport 需要设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,user-scalable=no"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面标题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 性能：DNS预获取，将网站中访问的资源服务器域名一一定义在此 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 性能：预连接、与查询、预加载，注意：预查询、预加载 不等于提前执行，仅是资源准备就绪 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- preconnect: 预先建立tcp连接，根据需要，将网站访问资源服务器域名一一定义在此 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- prefetch: 能够让浏览器预加载一个资源（HTML，JS，CSS或者图片等），可以让用户跳转到其他页面时，响应速度更快。</span></span><br><span class="line"><span class="comment">  Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.js"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当部分资源在页面加载完成后即刻需要时，也就说很有必要的资源。可以使用preload,as属性设置文件类型</span></span><br><span class="line"><span class="comment">  preload不阻塞文档onload</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/image.png"</span> <span class="attr">as</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 应用css，头部不出现引用js文件，避免阻塞渲染 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/css/app.css"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 站点：favicon --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/png"</span> <span class="attr">sizes</span>=<span class="string">32x32</span> <span class="attr">href</span>=<span class="string">"/img/icons/favicon-32x32.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/png"</span> <span class="attr">sizes</span>=<span class="string">16x16</span> <span class="attr">href</span>=<span class="string">"/img/icons/favicon-16x16.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>脚本不支持或被关闭时的提醒信息，可有可无。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 应用入口元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 底部引用脚本：初始化页面渲染完成后，在执行脚本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//yourwebsite.com/js/chunk-vendors.2ab46520.js"</span>&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//yourwebsite.com/js/app.ff0e0ca9.js"</span>&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>移动端补充：</p><ul><li><p>取消iso文本框阴影</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input,</span><br><span class="line">textarea &#123;</span><br><span class="line">    border: 0; /* 方法1 */</span><br><span class="line">    -webkit-appearance: none; /* 方法2 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>电话号码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 关闭电话号码识别： --&gt;</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 开启电话功能： 点击拨打电话 --&gt;</span><br><span class="line">&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启短信功能：点击发送消息 --&gt;</span><br><span class="line">&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li>邮箱</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 关闭邮箱地址识别： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启邮件发送： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">mailto:</span>&gt;</span>mobile@gmail.com"&gt;mobile@gmail.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>指定 iOS 的 safari 顶端状态条的样式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可选default、black、black-translucent --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>长按复制</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>http概述</title>
      <link href="/2018/11/27/http1/"/>
      <url>/2018/11/27/http1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-的基本性质"><a href="#HTTP-的基本性质" class="headerlink" title="HTTP 的基本性质"></a>HTTP 的基本性质</h1><h2 id="HTTP-是简单的节"><a href="#HTTP-是简单的节" class="headerlink" title="HTTP 是简单的节"></a>HTTP 是简单的节</h2><p>虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。</p><h2 id="HTTP-是可扩展的节"><a href="#HTTP-是可扩展的节" class="headerlink" title="HTTP 是可扩展的节"></a>HTTP 是可扩展的节</h2><p>在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 h<code>eaders</code>达成语义一致，新功能就可以被轻松加入进来。</p><h2 id="HTTP-是无状态，有会话的节"><a href="#HTTP-是无状态，有会话的节" class="headerlink" title="HTTP 是无状态，有会话的节"></a>HTTP 是无状态，有会话的节</h2><p>HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p><blockquote><p>注意，HTTP本质是无状态的，使用<code>Cookies</code>可以创建有状态的会话。同一台机器cookie是相同了，这样服务器就能辨别客户端访问身份；</p></blockquote><h2 id="HTTP-和连接节"><a href="#HTTP-和连接节" class="headerlink" title="HTTP 和连接节"></a>HTTP 和连接节</h2><p>一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。</p><blockquote><p>这也是为什么http协议是建立在tcp协议之上的原因，确保每次连接可靠，但无需实时可用；</p></blockquote><p>HTTP/1.0为每一个请求/响应都打开一个TCP连接，导致了2个缺点：打开一个TCP连接需要多次往返消息传递，因此速度慢。但当多个消息周期性发送时，这样就变得更加高效：暖连接比冷连接更高效。</p><blockquote><p>上边我们说到，http 请求无需实时可用，但从实际网页需求来看，没此简历tcp连接需要3次握手，这种转身就忘记的特性，势必带来了<code>效率</code>问题，因此在http1.1中引入了长连接；也就说我们看到的头部 <code>Connection: keep-alive</code> 信息；</p></blockquote><blockquote><p> 长连接和短连接<br>Connection: keep-alive<br>Connection: close</p></blockquote><p>为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 </p><p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。</p><h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><p>由于三部分组成：</p><ul><li>请求行</li></ul><p>HTTP请求是由客户端发出的消息，用来使服务器执行动作。比如：<code>GET /background.png HTTP/1.0</code> 起始行 (start-line) 包含三个元素：方法、目标(URL)、协议版本</p><ul><li>请求头 headers</li></ul><p>来自请求的 HTTP headers 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号 (‘:’) 和一个结构取决于 header 的值。 整个 header（包括值）由一行组成，这一行可以相当长。</p><ul><li>请求体 body</li></ul><p>请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。</p><h2 id="http-响应"><a href="#http-响应" class="headerlink" title="http 响应"></a>http 响应</h2><ul><li>状态行</li></ul><p>比如<code>HTTP/1.1 404 Not Found。</code>包含以下信息：协议版本 状态 状态文本；</p><ul><li>headers</li></ul><p>与请求头规则一致；</p><ul><li>响应体 body</li></ul><p>响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。</p><h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><h3 id="http1-1-缺点"><a href="#http1-1-缺点" class="headerlink" title="http1.1 缺点"></a>http1.1 缺点</h3><ul><li>header 没有被压缩；</li><li>不同的请求，即使header 信息相似，仍然会重复传输，从共享角度看是显得多余的；</li></ul><h2 id="http2-新特点"><a href="#http2-新特点" class="headerlink" title="http2 新特点"></a>http2 新特点</h2><ul><li>多路复用</li></ul><p>HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 多路复用 (multiplexing) 的过程，它允许更有效的底层 TCP 连接。</p><p>HTTP/2 帧机制是在 HTTP/1.x 语法和底层传输协议之间增加了一个新的中间层，而没有从根本上修改它，即它是建立在经过验证的机制之上。</p><p>http2 不需要前端做任何升级，只有浏览器支持，服务器端开启，则自动切换到http2上，但必须是https协议网站；</p><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/13819/Binary_framing2.png" alt=""></div><h2 id="http-连接管理"><a href="#http-连接管理" class="headerlink" title="http 连接管理"></a>http 连接管理</h2><p> 包括：短连接、长连接、流水线，连接能管理的是客户端、服务器，中间的代理如果不支持时（路由器），则会使失效；</p><ul><li>http1.0 使用短连接（Connection: close），每次请求时，都需要优建立连接；</li><li>http1.1 默认使用了长连接（Connection: keep-alive），第一次请求时，建立了连接且会保持一段时间，之后请求不在重复建立连接，节省很多开销；</li><li>流水线，多个连续的请求不用等待立即返回就可以被发送，这样就减少了耗费在网络延迟上的时间。但在http1.1中由于各种受限，<br>可应用性没有展开。好的一点是在http2中得到了支持；<br>默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</li></ul><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png" alt=""></div>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>前端知识点分类</title>
      <link href="/2018/11/27/resource-md/"/>
      <url>/2018/11/27/resource-md/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><ul><li>vue.js基本</li><li>vuex 数据状态管理</li><li>axios使用</li><li>vue-router</li><li>pc端ui和移动端ui</li></ul><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul><li>闭包</li><li>作用域、作用域链路</li><li>继承</li><li>es2015新特性</li></ul><h1 id="web原理"><a href="#web原理" class="headerlink" title="web原理"></a>web原理</h1><ul><li>http</li><li>304缓存</li><li>cors共享</li><li>浏览器原理:<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li></ul><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ul><li>koa.js</li></ul><h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><ul><li>webpack</li><li>客户端es6，vue,react配置</li><li>服务器端es6</li></ul><h1 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h1><ul><li>eslint配置和常用标准</li><li>单元测试、覆盖率、用户测试：mocha,karma,e2e<h1 id="了解库"><a href="#了解库" class="headerlink" title="了解库"></a>了解库</h1></li><li>测试框架,比如 Mocha、Jasmine、Karma、Tape</li><li>mock.js</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>抓包工具，如charles使用</li><li>浏览器开发者工具</li><li>编辑器</li><li>检查 Cache 相关 HTTP 首部的工具. <a href="https://redbot.org/" target="_blank" rel="noopener">RedBot</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>rest接口开发模式</li></ul><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>axios遇到OPTIONS请求</title>
      <link href="/2017/06/09/axios/"/>
      <url>/2017/06/09/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。大部分前端工程师在使用axios或者类似fetch库，<br>方便易用，但在CORS跨域资源获取中遇到的问题不少。</p><h2 id="axios-使用"><a href="#axios-使用" class="headerlink" title="axios 使用"></a>axios 使用</h2><p>省略…<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">文档</a></p><h2 id="什么情况下需要-CORS-？"><a href="#什么情况下需要-CORS-？" class="headerlink" title="什么情况下需要 CORS ？"></a>什么情况下需要 CORS ？</h2><p>在下列场景中使用跨域 HTTP 请求：</p><ul><li>由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用 drawImage 将 Images/video 画面绘制到 canvas</li></ul><blockquote><p>这次说的是第一种 XMLHttpRequest 发起的跨域 HTTP 请求。</p></blockquote><blockquote><p>大家可能会认为，项目中客户端无非是发起get、post请求，是否允许客户端访问，是服务器端要控制的，只要服务器响应头设置</p></blockquote><p>‘Access-Control-Allow-Origin’:’*’ //所有客户端<br>‘Access-Control-Allow-Origin’:’请求Origin值’  //允许特定客户端</p><p>其次，服务器响应对应个get、post请求类型和路径，这样就OK了。</p><h2 id="真的OK吗"><a href="#真的OK吗" class="headerlink" title="真的OK吗?"></a>真的OK吗?</h2><p>如果是OK的，说明应用场景叫简单；属于<code>简单请求</code>。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ul><li>使用下列方法之一：<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type （需要注意额外的限制）</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值仅限于下列三者之一：<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li><li>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</li><li>请求中没有使用 ReadableStream 对象。</li></ul></li></ul><blockquote><p>满足以上条件时，是简单请求，浏览器发送一次请求。</p></blockquote><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>与简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS   方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><blockquote><p>在破坏掉简单请求规则后，浏览器首先发起一个method=OPTIONS 的请求，询问服务器是否可以跨域等要求(跨域、方法、自定义头信息等特殊要求)，不满足则直接拒绝；如果同意时，则响应，并且响应头 新增 如下两个字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods&apos; // 服务器所支持的请求方法</span><br><span class="line">Access-Control-Allow-Headers&apos; // 浏览器自定义的头部</span><br></pre></td></tr></table></figure></p></blockquote><p>加入原有请求是POST方式，在获的允许到，浏览器会再次发送一次POST请求；</p><blockquote><p>举个生活中的简单例子，现在小区周边的学校晚上都开放了，允许居民健身运动；<br>比如春节期间，你晚上去学校了，到了门口一看，门卫说假期不对外开放，结果是不能进去健身了，而且白跑一趟，浪费时间和精力，这相当于一个简单请求；<br>优化：去之前先打个电话，询问下是否可以健身，可以就去，不可以就去做其他事情，是不是很省事情呀，这个过程就是 OPTIONS 请求。</p></blockquote><p>继续故事，第二天，你仍然事先打电话询问，然后再做下一步打算，去或不去；时间多了，你会烦死的，门卫也会烦死的；<br>优化：多次电话询问后，门卫聪明了，这次他告诉你，接下来7天内每天都开放，这样你在最近7天肯定不会在打电话先咨询了；这个时间就是 OPTIONS 请求响应头<code>Access-Control-Max-Age</code>中设置缓存时间。</p><p>从中我们应该能感知到，在非简单请求时，浏览器认为是个<code>重请求</code>，超出了服务器默认设置，浏览器会认为可能会被服务器拒绝掉，因此携带大量数据去请求<code>可能白跑一趟</code>，做了优化，先<code>预检请求</code>,看下服务器是否允许，允许多久等，对于跨域请求性能有很大提高；</p><h4 id="当请求满足下述任一条件时，即应首先发送预检请求："><a href="#当请求满足下述任一条件时，即应首先发送预检请求：" class="headerlink" title="当请求满足下述任一条件时，即应首先发送预检请求："></a>当请求满足下述任一条件时，即应首先发送预检请求：</h4><ul><li><p>使用了下面任一 HTTP 方法：</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul></li><li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (but note the additional requirements below)</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值不属于下列之一:<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li><li>请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。</li><li>请求中使用了ReadableStream对象。</li></ul><h2 id="服务器改造"><a href="#服务器改造" class="headerlink" title="服务器改造"></a>服务器改造</h2><p>大部分情况下，我们设置了跨域，但忽略了对 OPTIONS 响应的处理，最终没有处理或者返回404，错误路径；</p><p>以下是 koa.js 简单处理，OPTIONS 请求返回204，允许访问，当然你可以针对路径设置 OPTIONS；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * [cros跨域处理]</span><br><span class="line"> * @param  &#123;[type]&#125; async (ctx,         next [description]</span><br><span class="line"> * @return &#123;[type]&#125;       [description]</span><br><span class="line"> */</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line">  if (ctx.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">    // 请求method =options，是预检请求</span><br><span class="line">    // 此时做些简单，处理，如果希望访问则如下，不希望时，</span><br><span class="line">    // 设置缓存时间，下次 OPTIONS 请求不会再次发起，直接使用真实的请求如GET、POST、PUT</span><br><span class="line">    // ctx.set(&quot;Access-Control-Max-Age&quot;, 86400000);</span><br><span class="line">    ctx.set(&apos;Access-Control-Allow-Methods&apos;, &apos;OPTIONS, GET, PUT, POST, DELETE&apos;);</span><br><span class="line">    ctx.set(&apos;Access-Control-Allow-Headers&apos;, ctx.header[&apos;access-control-request-headers&apos;]);</span><br><span class="line">    // 发回204状态码，数据是空</span><br><span class="line">    ctx.response.status = 204;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>性能优化</title>
      <link href="/2017/04/23/performance/"/>
      <url>/2017/04/23/performance/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul><li>缓存，如localStorage</li><li>预加载</li></ul><p>利用link rel=”preload” 提前下载，但并不会阻塞页面渲染；<br>as属性 设置加载的媒体类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;</span><br></pre></td></tr></table></figure></p><ul><li>图片合并</li><li><p>资源加载顺序<br>css 在 head区域加载,<br>js在尾部加载；如果js页面与渲染无关系，可以设置异步；</p></li><li><p>开发PWA 单页面应用；减少页面跳转和资源请求；</p></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul><li>cors缓存，比如options 请设置 头 Access-Control-Max-Age；</li><li>升级到http2协议</li><li>合理的缓存设置</li><li>gzip</li><li>文件压缩，css、js资源</li><li>避免重定向，重定向的后果是客户端需要发起多次请求后才获取到真正资源；</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>cors跨域请求</li><li>网站资源预加载，在html中设置，包括dns-prefetch DNS;pre-loader css,js;</li><li>网络资源文件大小控制，比如压缩；</li><li>减少请求次数</li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li>DOM 增删改， 操作次数，最好一次性触发页面reflow、repaint；</li><li>减少作用域链查找，需要频繁访问的变量，最好在本作用域内可以找到；</li><li>精简css文件，混淆、压缩；工程化打包工具会处理；source-map文件在外部或者不输出；</li><li>减小js文件：如删除js文件中重复代码，提取公共组件或函数；</li><li>ajax请求，首选get,会被浏览器缓存，post浏览器不缓存；</li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li>css选择器 深度不宜多；css 引擎是从右往左的，左边不要添加太多限定词；</li><li>css 动画优先于js；</li><li>勿用css表达式；</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>cookie</title>
      <link href="/2016/12/28/cookie/"/>
      <url>/2016/12/28/cookie/</url>
      
        <content type="html"><![CDATA[<h2 id="cookie安全"><a href="#cookie安全" class="headerlink" title="cookie安全"></a>cookie安全</h2><ul><li>设置 secure 属性；仅允许 cookie 在https 协议下在服务器和客户端之间传输；</li><li>设置 HttpOnly 属性；禁止 JavaScript 读取，同时可以防止 xss 攻击；</li><li>敏感信息不再 cookie 中存储；</li><li>类似论坛、发帖、评论，过滤掉非法信息，避免注入代码；</li><li>cookie 和 session 双重验证；</li><li>二次验证码</li><li>优化网站，提升规则策略，使攻击者攻击成本增加；</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>xss 攻击与防御</title>
      <link href="/2016/08/15/xss/"/>
      <url>/2016/08/15/xss/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS定义"><a href="#XSS定义" class="headerlink" title="XSS定义"></a>XSS定义</h2><p>跨站脚本攻击Cross-site scripting (XSS)是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。</p><blockquote><p>简单点：用户访问网站时，浏览器上执行了<code>不是网站作者意图</code>的代码，而是一个<code>捣乱者</code>的意图，不受控作者控制了，那么<code>捣乱者</code>就可能会窃取访问者的信息；</p></blockquote><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>窃取用户的cookie，localStorage;</li><li>将用户重定向到钓鱼网站，比如跳转到一个似真银行网站，当你输入用户名和密码时登录时，实际是在钓鱼网站操作。</li><li>破坏网站内容和结构；</li><li>注入广告、垃圾信息；</li></ul><h2 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h2><p>如果您的网站是与用户有数据交互的，比如论坛，基本流程是用户发帖子、帖子被其他用户浏览，帖子内容网站管理员不可以扭曲，需保证一致性，借此，恶意发帖人会注入一段javascript脚本，然后上传到服务器，最后帖子被查看时，服务器原样吐出来，问题是吐出来时已经不是网站作者的原有意图了；</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>第一种：replace 内容存储前处理，在写入数据库时，过滤掉不安全内容，然后在存储；<br>特点：用户编辑时，已经不是当初内容了，而且服务器上也找不到原来内容；</li><li>第二种：filter 响应时，过滤掉不安全内容，只输出安全内容，像php中有过滤规定标签的函数可以处理；<br>特点：用户编辑时，已经不是当初内容了，但服务器上有；</li><li>第三种，在浏览器端展现时，htmlEncode 编码，使其不可以在浏览器上执行；<br>特点：用户编辑时，看到的就是原有内容；</li></ul><blockquote><p>从内容一致性原则看，第三种最好，文本输入框输入不做限制，也许用户输入标签和脚本 本来就是他的目的，比如技术帖子，正常的需求。但前段工程师在输出页面时必须 htmlEncode 编码输出页面，不给不法者运行环境；</p></blockquote><p>三种各有特点，使用场景不一样，比如第一种，业务需求是不允许输入特殊字符，服务器在存储前做校验，不通过时告知用户，只有符合规则了才给予了保存。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>浏览器的DOM</title>
      <link href="/2016/06/20/dom/"/>
      <url>/2016/06/20/dom/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“Document”对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可翻译成如下的 DOM 树：</p><div align="center"><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png" alt=""></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>.children[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 返回 "[object HTMLHtmlElement]"，证明了 document的第一个子元素是 html，当然也只有一个；</span></span><br><span class="line"><span class="built_in">document</span>.children.length</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h1 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h1><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）</p><div align="center"><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png" alt=""></div><h1 id="webkit-流程"><a href="#webkit-流程" class="headerlink" title="webkit 流程"></a>webkit 流程</h1><div align="center"><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt=""></div><h2 id="css的阻塞"><a href="#css的阻塞" class="headerlink" title="css的阻塞"></a>css的阻塞</h2><h3 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h3><p>如下测试中，文件 <a href="http://127.0.0.1:5000/css" target="_blank" rel="noopener">http://127.0.0.1:5000/css</a> 设置了延迟，其表现：</p><ol><li>在等待过程中，后边的css文件gitbook-min.css 也发出了请求，且下载成功了，说明css不会阻塞其他css文件下载；</li><li>但页面上没有可视内容，是一片空白；</li><li>另外元素 <div id="out">dom</div> 通过 document.getElementById(‘out’) 查看是存在的；</li></ol><blockquote><p>结论：css 不会阻塞其他css下载；不会阻塞dom树构建；但会影响页面渲染；也就是说，页面渲染需要dom tree 和 css rules都准备完成，然后在合并为render tree，最后渲染；卡壳等待原因是在css rules处；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  body&#123;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h3><p>以下：在头部插入脚本时，在<a href="http://127.0.0.1:5000/css" target="_blank" rel="noopener">http://127.0.0.1:5000/css</a> 请求过程中，js未执行，dom未渲染；</p><blockquote><p>结论：css 在请求期间，不会阻塞其他css样式文件，但会阻js；注意加载位置顺序：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://a.apebook.org/gitbook-min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined">alert(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://www.bootcss.com/assets/css/site.min.css?1542483686613"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试三"><a href="#测试三" class="headerlink" title="测试三"></a>测试三</h3><p>以下：css延迟脚本在页面底部，并且设置body是黄色，在执行等待期间，其他css文件已下载，页面是白屏等待，并未看到黄色背景，此时body,div等dom元素都是存在的，页面仍未看到效果；</p><blockquote><p>结论：css文件无论在什么位置，只要没加载完成，都会阻塞dom的渲染; 在渲染之前， Style Rules必须准备就绪，在未就绪前，渲染和dom 都是无意义的；但是浏览器也做了超时控制，不可能无限制等待，因为没有css时，简单的dom也是可用的，因此当外部css文件超时后，就被忽略掉，使用了页面黄色背景，并且完成页面渲染；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://a.apebook.org/gitbook-min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://www.bootcss.com/assets/css/site.min.css?1542483686613"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  body&#123;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span> <span class="attr">style</span>=<span class="string">"color: blue;"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试四"><a href="#测试四" class="headerlink" title="测试四"></a>测试四</h3><p>css 延迟100秒，js延迟5秒；</p><ul><li>在css等待响应过程中；js在5后下载成功；</li><li>获取dom不存在，此时页面body元素都看不到；</li><li>js文件下载后，但未被执行；</li></ul><p>分析下浏览器设计思路：</p><ul><li>浏览器在请求下载 css和js外部文件，是不会相互阻塞的下载，阻塞的是执行和使用资源；</li><li>资源的使用是相互依赖的；</li><li>js准备就绪，执行的前提是dom存在；</li><li>若需要dom，则css文件需存在；</li></ul><p>设想：css文件在等待下载中，js文件已经准备好了，如果允许dom准备，那么js文件执行，执行后，此时css文件仍然未下载完成，页面还是看不到，那么执行这个js任务有什么意义；执行js文件后，如果css文件下载完成，页面渲染，试想看到的页面是js的目的吗，加入js更改了背景颜色，后来css又更改了背景颜色，岂不是乱套了。记住，js修改页面时，允许是页面已经就绪，否则混乱了；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:5000/js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span> <span class="attr">style</span>=<span class="string">"color:blue;"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试五"><a href="#测试五" class="headerlink" title="测试五"></a>测试五</h3><p>css 延迟100秒，js延迟5秒；</p><ul><li>页面在css、js等待下载过程中，dom很快生成了，但页面是空白的，因为还没有渲染；</li><li>5秒后，js文件下载完成，css还在等待下载中，但js未执行，即使dom存在了，因为css文件在前边，如果此时js执行了，后边css文件又影响了页面渲染，那么js执行的效果未必是开发者可以控制的或开发者的目的；</li></ul><blockquote><p>结论：页面在等待下载css过程中，在生成新的渲染之前，是不允许执行js的，必须等待生成新的渲染上下文后，再执行js；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://127.0.0.1:5000/css2&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;out&quot; style=&quot;color:blue;&quot;&gt;dom&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1:5000/js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="js-阻塞"><a href="#js-阻塞" class="headerlink" title="js 阻塞"></a>js 阻塞</h2><p>js延迟10秒；css 延迟3秒，</p><p>如下测试中，文件 <a href="http://127.0.0.1:5000/js" target="_blank" rel="noopener">http://127.0.0.1:5000/js</a> 设置了延迟返回，是个js文件，有个<code>alert(1)</code>片段；</p><ul><li>在js和css都未完成下载时，dom不存在；</li><li>在js等待下载，css已下载，dom仍然不存在；</li><li>js下载完成，执行了alert(1)，但为关闭，也就是说脚本执行了，但未执行完之前，dom仍然不存在；</li><li>js完成执行后，生成了dom ,渲染了页面；</li></ul><blockquote><p>结论：js文件会阻塞后续js文件执行和dom生成,为了尽快渲染dom，应该js文件在页面底部加载，头部禁止，除非业务必须使用的资源脚本；<br>js文件是同步执行，必须执行完成一个后，才能执行下一个js或页面渲染；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:5000/js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="浏览器js和js位置"><a href="#浏览器js和js位置" class="headerlink" title="浏览器js和js位置"></a>浏览器js和js位置</h2><p>位置对执行顺序的影响</p><ul><li>css规则：css在文件头部，目的是准备就绪css rules，规则未准备好之前页面不渲染，禁止用户看页面，防止页面跳动;</li><li>页面渲染：执行body区域，生成dom tree,同时与css合并生成render tree,最终渲染完成，用户看到初始页面；</li><li>执行脚本：顺序执行脚本任务，动态更改css和dom，重新完成一次渲染；</li></ul><blockquote><p>以上是用户体验最好的加载顺序；<br>资源请求下载是异步的，不会被阻塞；<br>js和css相互阻塞的是执行、执行、执行；</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>前端规范</title>
      <link href="/2016/01/03/standard/"/>
      <url>/2016/01/03/standard/</url>
      
        <content type="html"><![CDATA[<h2 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h2><ol><li><p>资源存放位置有分类， html, css, js, images文件均归档至约定的目录中;</p></li><li><p>html文件命名: 英文命名, 后缀.html或.htm. 同时将统一页面文件放于同目录中, 以方便后端添加功能时查找对应页面;</p></li><li><p>css文件命名: 英文命名, 后缀.css. 共用base.css, 首页index.css, 其他页面依实际模块需求命名.;</p></li><li><p>Js文件命名: 英文命名, 后缀.js. 共用common.js, 其他依实际模块需求命名。</p></li><li><p>文件编码 <code>utf-8</code>;</p></li></ol><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><h3 id="结构、样式、行为分离"><a href="#结构、样式、行为分离" class="headerlink" title="结构、样式、行为分离"></a>结构、样式、行为分离</h3><p>尽量确保文档和模板只包含 HTML 结构，样式都放到样式表里，行为都放到脚本里。<br>也就是说 html、css、js文件做好自己的职责，不要混合编写代码，目的就是为了清晰、方便控制；</p><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>自闭合标签，无需关闭，如 img input br hr</li><li>尽量减少标签数量</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>双引号</li><li>属性顺序，id、class、name、data-xxx、src、for、type、href、title、alt;</li><li>bool属性不用设值</li></ul><h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><p>没有 CSS 的 HTML 是一个语义系统而不是 UI 系统，因此在无css的情况下，要确保信息可阅读。<br>同时语义化有助于SEO以及他人了解开发者意图；</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><ul><li><p>文档类型 <code>&lt;!DOCTYPE html&gt;</code></p></li><li><p>IE 兼容模式<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code>,优先chrome，否则IE最新版本</p></li><li><p>viewport</p></li><li>SEO，keywords、description的描述</li><li>定义favicon 确保不出现404；<code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;path/to/favicon.ico&quot;&gt;</code> 或者根目录携带favicon.ico；</li><li>加载css；</li><li>js文件视情况选择加载，非必须的此处不加载，js执行和页面渲染时互斥的，防止阻塞。</li><li>其他有意义meta;<blockquote><p>总之，项目中可以针对pc和移动端，定义两套HEAD魔板；</p></blockquote></li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>慎用高消耗样式，主要集中在图形类</li><li>避免重排，常见的重排元素:<ul><li>width</li><li>height</li><li>padding</li><li>margin</li><li>display</li><li>border-width</li><li>position</li><li>top</li><li>left</li><li>right</li><li>bottom</li><li>font-size</li><li>float</li><li>text-align</li><li>overflow-y</li><li>font-weight</li><li>overflow</li><li>font-family</li><li>line-height</li><li>vertical-align</li><li>clear</li><li>white-space</li><li>min-height</li></ul></li><li><p>display 属性会影响页面的渲染，请合理使用。简单原则是设置好其他属性，最后再设置display;</p><ul><li><p>display: inline后不应该再使用 width、height、margin、padding 以及 float；</p></li><li><p>display: inline-block 后不应该再使用 float；</p></li><li><p>display: block 后不应该再使用 vertical-align；</p></li><li><p>display: table-* 后不应该再使用 margin 或者 float；</p></li></ul></li><li><p>避免滥用 float,float计算量较大</p></li><li><p>利用硬件能力；</p><p>例如：使用 translate3d 右移 500px 的动画流畅度要明显优于直接使用 left：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.ball-1 &#123;</span></span><br><span class="line"><span class="comment">  transition: -webkit-transform .5s ease;</span></span><br><span class="line"><span class="comment">  -webkit-transform: translate3d(0, 0, 0);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.ball-1.slidein&#123;</span></span><br><span class="line"><span class="comment">  -webkit-transform: translate3d(500px, 0, 0);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.ball-2 &#123;</span></span><br><span class="line"><span class="comment">  transition: left .5s ease; left：0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.ball-2.slidein &#123;</span></span><br><span class="line"><span class="comment">  left：500px;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>提升css选择器性能</p><p>  css 是从右到左解析；原则是层次少、不冗余，降低css过滤和检索时间；</p><ul><li><p>避免使用通用选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> * &#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况。</p></blockquote></li><li><p>避免使用标签或 class 选择器限制 id 选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line">button#backButton &#123;…&#125;</span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line">#newMenuIcon &#123;…&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释：从右侧先找到 #backButton，在判断是否是button元素，两个步骤，#id已表明是唯一的，在此限定规则多此一举；</p></blockquote></li><li><p>避免使用标签限制 class 选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line">treecell.indented &#123;…&#125;</span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line">.treecell-indented &#123;…&#125;</span><br><span class="line"><span class="comment">/* Much to recommended */</span></span><br><span class="line">.hierarchy-deep &#123;…&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免使用子选择器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line">treehead treerow treecell &#123;…&#125;</span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line">treehead &gt; treerow &gt; treecell &#123;…&#125;</span><br><span class="line"><span class="comment">/* Much to recommended */</span></span><br><span class="line">.treecell-header &#123;…&#125;</span><br></pre></td></tr></table></figure></li><li><p>多用css继承特性</p><p>利用继承特性，无需给子元素设置样式；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not recommended */</span></span><br><span class="line"><span class="selector-id">#bookmarkMenuItem</span> &gt; <span class="selector-class">.menu-left</span> &#123; <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(blah) &#125;</span><br><span class="line"><span class="comment">/* Recommended */</span></span><br><span class="line"><span class="selector-id">#bookmarkMenuItem</span> &#123; <span class="attribute">list-style-image</span>: <span class="built_in">url</span>(blah) &#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>略：可以引入Eslint插件，使用airbnb公司规则，非常严格；</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>GC-垃圾回收</title>
      <link href="/2015/08/10/GC/"/>
      <url>/2015/08/10/GC/</url>
      
        <content type="html"><![CDATA[<h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>不管什么程序语言，内存生命周期基本是一致的：</p><ul><li>值得初始化，分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放\归还</li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>内容 “不在需要”时，将被回收，难度是如何界定是否不需要；JavaScript 引擎有两种解决方案；</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><p>它是最初的算法，存在一定的缺陷（循环引用），已经过时；2012年以后，主流浏览器使用了标记-清除算法；</p><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>标记清除算法从名称上看，可以拆分为两部分:标记(mark)和清除(sweep)。</p><p>此算法可以分为两个阶段，一个是标记阶段，一个是清除阶段，下面就分别做一下介绍。</p><ol><li>标记阶段:</li></ol><p>在此阶段，垃圾回收器会从mutator（应用程序）根对象开始遍历。</p><p>每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</p><ol start="2"><li>清除阶段:</li></ol><p>在此阶段中，垃圾回收器，会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</p><p>图示如下:</p><div style="text-align: center;"><img src="/img/gc.png" alt=""></div><p>在标记阶段，从跟对想1可以访问到B，从B又可以访问到E，那么B和E都是可到达对象，同样的道理，F、G、J和K都是可到达对象。在回收阶段，所有未标记为可到达的对象都会被垃圾回收器回收。</p><p><code>标记位置</code>是在<code>堆</code>内存上打标记；</p><ul><li>执行 var obj = {a:’some’}；后，给obj分配栈地址，同时给内容{}在堆内设置空间存储内容；</li><li>执行 obj = null后，栈和堆的关系被释放，也就是说内容堆可能会出现游离状态，没有被任何对象给引用；</li><li>GC 定时扫描 window下对象，只给能被引用到的堆做标记；</li><li>标记完成后，停止执行程序或者锁住，清除堆中未标记，释放空间；</li><li>GC回收动作完成后，应用程序继续执行；</li><li>过一段时间，GC再去扫描window，在堆中重新标记；</li></ul><p>特别说明:在垃圾回收阶段，应用程序的执行会暂停，等待回收执行完毕后，再恢复程序的执行。</p><p>参考：[<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management]" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management]</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>css</title>
      <link href="/2015/01/30/css/"/>
      <url>/2015/01/30/css/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-实际上如何工作？"><a href="#CSS-实际上如何工作？" class="headerlink" title="CSS 实际上如何工作？"></a>CSS 实际上如何工作？</h2><p>当浏览器显示文档时，它必须将文档的内容与其样式信息结合。它分两个阶段处理文档：</p><p>浏览器将 HTML 和 CSS 转化成 DOM （文档对象模型）。DOM在计算机内存中表示文档。它把文档内容和其样式结合在一起。<br>浏览器显示 DOM 的内容。</p><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/11781/rendering.svg" alt=""></div><h2 id="如何将你的-CSS-应用到你的-HTML-上"><a href="#如何将你的-CSS-应用到你的-HTML-上" class="headerlink" title="如何将你的 CSS 应用到你的 HTML 上"></a>如何将你的 CSS 应用到你的 HTML 上</h2><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul><h2 id="CSS-声明"><a href="#CSS-声明" class="headerlink" title="CSS 声明"></a>CSS 声明</h2><p>由于 属性名和属性值 结对构成；</p><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/16188/css_syntax_-_declaration.png" alt=""></div><h2 id="css-选择器分类"><a href="#css-选择器分类" class="headerlink" title="css 选择器分类"></a>css 选择器分类</h2><ul><li>简单选择器（Simple selectors）：通过元素类型、class 或 id 匹配一个或多个元素。</li><li>属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。</li><li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。</li><li>伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 </li><li>组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。</li><li>多重选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li></ul><h3 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h3><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类不是选择元素，而是元素的某些部分，或仅在某些特定上下文中存在的元素。它们有两种主要类型 ： 伪类和伪元素。</p><p>一个 CSS  伪类（pseudo-class） 是<code>一个以冒号(:)</code>作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:active</span></span><br><span class="line"><span class="selector-pseudo">:any</span></span><br><span class="line"><span class="selector-pseudo">:checked</span></span><br><span class="line"><span class="selector-pseudo">:default</span></span><br><span class="line"><span class="selector-pseudo">:dir()</span></span><br><span class="line"><span class="selector-pseudo">:disabled</span></span><br><span class="line"><span class="selector-pseudo">:empty</span></span><br><span class="line"><span class="selector-pseudo">:enabled</span></span><br><span class="line"><span class="selector-pseudo">:first</span></span><br><span class="line"><span class="selector-pseudo">:first-child</span></span><br><span class="line"><span class="selector-pseudo">:first-of-type</span></span><br><span class="line"><span class="selector-pseudo">:fullscreen</span></span><br><span class="line"><span class="selector-pseudo">:focus</span></span><br><span class="line"><span class="selector-pseudo">:hover</span></span><br><span class="line"><span class="selector-pseudo">:indeterminate</span></span><br><span class="line"><span class="selector-pseudo">:in-range</span></span><br><span class="line"><span class="selector-pseudo">:invalid</span></span><br><span class="line"><span class="selector-pseudo">:lang()</span></span><br><span class="line"><span class="selector-pseudo">:last-child</span></span><br><span class="line"><span class="selector-pseudo">:last-of-type</span></span><br><span class="line"><span class="selector-pseudo">:left</span></span><br><span class="line"><span class="selector-pseudo">:link</span></span><br><span class="line"><span class="selector-pseudo">:not()</span></span><br><span class="line"><span class="selector-pseudo">:nth-child()</span></span><br><span class="line"><span class="selector-pseudo">:nth-last-child()</span></span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type()</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type()</span></span><br><span class="line"><span class="selector-pseudo">:only-child</span></span><br><span class="line"><span class="selector-pseudo">:only-of-type</span></span><br><span class="line"><span class="selector-pseudo">:optional</span></span><br><span class="line"><span class="selector-pseudo">:out-of-range</span></span><br><span class="line"><span class="selector-pseudo">:read-only</span></span><br><span class="line"><span class="selector-pseudo">:read-write</span></span><br><span class="line"><span class="selector-pseudo">:required</span></span><br><span class="line"><span class="selector-pseudo">:right</span></span><br><span class="line"><span class="selector-pseudo">:root</span></span><br><span class="line"><span class="selector-pseudo">:scope</span></span><br><span class="line"><span class="selector-pseudo">:target</span></span><br><span class="line"><span class="selector-pseudo">:valid</span></span><br><span class="line"><span class="selector-pseudo">:visited</span></span><br></pre></td></tr></table></figure><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是<code>两个冒号 (::)</code>， 同样是添加到选择器后面去选择某个元素的某个部分。</p><p>我最熟悉的清除浮动 <code>.cleanfix</code>，就是利用了伪元素，给其设置样式和内容以此影响浮动；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::after</span><br><span class="line">::before</span><br><span class="line">::first-letter</span><br><span class="line">::first-line</span><br><span class="line">::selection</span><br><span class="line">::backdrop</span><br></pre></td></tr></table></figure></p><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><table><thead><tr><th>名称</th><th style="text-align:center">组合器</th><th style="text-align:left">选择</th></tr></thead><tbody><tr><td>选择器组</td><td style="text-align:center">A,B</td><td style="text-align:left">匹配满足A（和/或）B的任意元素</td></tr><tr><td>后代选择器</td><td style="text-align:center">A B</td><td style="text-align:left">匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）</td></tr><tr><td>子选择器</td><td style="text-align:center">A &gt; B</td><td style="text-align:left">匹配B元素，满足条件：B是A的<code>直接子节点</code></td></tr><tr><td>相邻兄弟选择器</td><td style="text-align:center">A + B</td><td style="text-align:left">匹配B元素，满足条件：B是A的<code>下一个兄弟节点</code>（AB有相同的父结点，并且B紧跟在A的后面）</td></tr><tr><td>通用兄弟选择器</td><td style="text-align:center">A ~ B</td><td style="text-align:left">匹配B元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</td></tr></tbody></table><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>颜色是由 Red、Green、Blue三个颜色调和，每个颜色256种</p><ul><li>名称：如 <code>red</code></li><li>16进制 如 <code>#ffff00</code>,其中两个表示一个颜色通道</li><li>RGB,如 <code>rgb(255,0,0);</code>, rbg是个函数，会帮我们计算，差别是每个是10进制</li><li><p>HSL 支持度比RGB稍微差一点的是HSL（旧版本的IE浏览器不支持），这是在众多开发者对其产生兴趣之后才实现的——hsl()函数接受三个表示色调、饱和度以及明度的参数，使用与上述三种不同的方式来区分大约1670万种颜色：</p><ul><li>色调：颜色的底色调。这个值在0到360之间，表示色轮的角度。</li><li>饱和度：饱和度是多少？这需要一个从0-100%的值，其中0是没有颜色（它将显示为灰色），100%是全彩色饱和度。</li><li>明度：颜色有多亮或明亮？这需要一个从0-100%的值，其中0是无光（它会出现全黑的），100%是充满光的（它会出现全白）。</li></ul></li><li><p>RGBA 和 HSLA 是RGB、HSL的对应透明度transparency函数；</p></li></ul><blockquote><p>颜色数值颜色，在chrome开发者工具，颜色面板可以转化查看;css更多函数值另查手册；</p></blockquote><blockquote><p><code>RGBA透明度与opacity属性差别</code>，opacity除了影响自身透明，还影响了子节点透明度，rgba只设置了自己；</p></blockquote><h3 id="选择器计算规则"><a href="#选择器计算规则" class="headerlink" title="选择器计算规则"></a>选择器计算规则</h3><p>一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字：</p><ul><li>千位：如果声明是在style 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。</li><li>百位：在整个选择器中每包含一个ID选择器就在该列中加1分。</li><li>十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。</li><li>个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。</li></ul><h3 id="float-元素如何工作"><a href="#float-元素如何工作" class="headerlink" title="float 元素如何工作"></a>float 元素如何工作</h3><p>浮动元素会脱离正常的文档布局流，并吸附到<code>其父容器的左边 flaot:left</code>。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</p><p>注意浮动内容仍然遵循盒子模型诸如外边距和边界。我们设置一下图片右侧的外边距就能阻止右侧的文字紧贴着图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">.clearfix &#123;</span><br><span class="line">  zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.fn-clear &#123;</span><br><span class="line">  zoom: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  display: block;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  content: &quot; &quot;;</span><br><span class="line">  clear: both</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫外边距折叠, 我们之前也遇到过。</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
