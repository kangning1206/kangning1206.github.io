<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>css-select</title>
      <link href="/2018/12/03/css-select/"/>
      <url>/2018/12/03/css-select/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">权重</th></tr></thead><tbody><tr><td style="text-align:left">!important</td><td style="text-align:left">Infinity</td></tr><tr><td style="text-align:left">行间样式</td><td style="text-align:left">1000</td></tr><tr><td style="text-align:left">id</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">class、属性、伪类</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">标签、伪元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">通配符</td><td style="text-align:left">0</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>margin-collapsing</title>
      <link href="/2018/12/03/margin-collapsing/"/>
      <url>/2018/12/03/margin-collapsing/</url>
      
        <content type="html"><![CDATA[<p>margin collapsing</p><p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠（因为这里触发了 块格式化上下文 Block Formatting Context， BFC）。</p><figure style="text-align: center;"><br>  <img src="http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_1.gif" alt=""><br>    <figcaption>相邻元素</figcaption><br></figure><figure style="text-align: center;"><br>  <img src="http://www.w3school.com.cn/i/ct_css_margin_collapsing_example_2.gif" alt=""><br>    <figcaption>父子元素</figcaption><br></figure><figure><br>    <figcaption></figcaption><br></figure><figure><br>    <figcaption></figcaption><br></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>css-box 盒子塌陷</title>
      <link href="/2018/12/03/css-box/"/>
      <url>/2018/12/03/css-box/</url>
      
        <content type="html"><![CDATA[<h2 id="盒子塌陷"><a href="#盒子塌陷" class="headerlink" title="盒子塌陷"></a>盒子塌陷</h2><h3 id="什么是盒子塌陷"><a href="#什么是盒子塌陷" class="headerlink" title="什么是盒子塌陷"></a>什么是盒子塌陷</h3>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>BFC</title>
      <link href="/2018/12/03/BFC/"/>
      <url>/2018/12/03/BFC/</url>
      
        <content type="html"><![CDATA[<p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p><code>块格式化上下文包含创建它的元素内部的所有内容.</code> BFC可以解决盒子塌陷；</p><p>下列方式会创建块格式化上下文：</p><ul><li>根元素或包含根元素的元素</li><li>浮动元素（元素的 float 不是 none）</li><li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li><li>行内块元素（元素的 display 为 inline-block）</li><li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li><li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li><li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li><li>overflow 值不为 visible 的块元素</li><li>display 值为 flow-root 的元素</li><li>contain 值为 layout、content或 strict 的元素</li><li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li><li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li><li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li><li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。<br>块格式化上下文包含创建它的元素内部的所有内容.</li></ul><p>块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>htmlTempleate</title>
      <link href="/2018/12/01/htmlTempleate/"/>
      <url>/2018/12/01/htmlTempleate/</url>
      
        <content type="html"><![CDATA[<p>推荐一种 react 或者 vue 渲染 html页面模板，目的接在提高用户体验和性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文档类型默认Html5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据需要设置语言或者移除lang --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-cn"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 需要保留，页面编码格式，推荐uft-8 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 针对IE8设置，其他浏览器无效 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果IE有安装Google Chrome Frame，那么就走安装的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SEO: 页面关键词 keywords --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"your keywords"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SEO: 页面描述内容 description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"your description"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- viewport 需要设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,user-scalable=no"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 页面标题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 性能：DNS预获取，将网站中访问的资源服务器域名一一定义在此 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 性能：预连接、与查询、预加载，注意：预查询、预加载 不等于提前执行，仅是资源准备就绪 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- preconnect: 预先建立tcp连接，根据需要，将网站访问资源服务器域名一一定义在此 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- prefetch: 能够让浏览器预加载一个资源（HTML，JS，CSS或者图片等），可以让用户跳转到其他页面时，响应速度更快。</span></span><br><span class="line"><span class="comment">  Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.js"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当部分资源在页面加载完成后即刻需要时，也就说很有必要的资源。可以使用preload,as属性设置文件类型</span></span><br><span class="line"><span class="comment">  preload不阻塞文档onload</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/chunk.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/image.png"</span> <span class="attr">as</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 应用css，头部不出现引用js文件，避免阻塞渲染 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//yourwebsite.com/css/app.css"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 站点：favicon --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/png"</span> <span class="attr">sizes</span>=<span class="string">32x32</span> <span class="attr">href</span>=<span class="string">"/img/icons/favicon-32x32.png"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">type</span>=<span class="string">"image/png"</span> <span class="attr">sizes</span>=<span class="string">16x16</span> <span class="attr">href</span>=<span class="string">"/img/icons/favicon-16x16.png"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noscript</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>脚本不支持或被关闭时的提醒信息，可有可无。<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 应用入口元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 底部引用脚本：初始化页面渲染完成后，在执行脚本 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//yourwebsite.com/js/chunk-vendors.2ab46520.js"</span>&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//yourwebsite.com/js/app.ff0e0ca9.js"</span>&gt;</span><span class="undefined"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>http概述</title>
      <link href="/2018/11/27/http1/"/>
      <url>/2018/11/27/http1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-的基本性质"><a href="#HTTP-的基本性质" class="headerlink" title="HTTP 的基本性质"></a>HTTP 的基本性质</h1><h2 id="HTTP-是简单的节"><a href="#HTTP-是简单的节" class="headerlink" title="HTTP 是简单的节"></a>HTTP 是简单的节</h2><p>虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。</p><h2 id="HTTP-是可扩展的节"><a href="#HTTP-是可扩展的节" class="headerlink" title="HTTP 是可扩展的节"></a>HTTP 是可扩展的节</h2><p>在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 h<code>eaders</code>达成语义一致，新功能就可以被轻松加入进来。</p><h2 id="HTTP-是无状态，有会话的节"><a href="#HTTP-是无状态，有会话的节" class="headerlink" title="HTTP 是无状态，有会话的节"></a>HTTP 是无状态，有会话的节</h2><p>HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。这就带来了一个问题，用户没有办法在同一个网站中进行连续的交互，比如在一个电商网站里，用户把某个商品加入到购物车，切换一个页面后再次添加了商品，这两次添加商品的请求之间没有关联，浏览器无法知道用户最终选择了哪些商品。而使用HTTP的头部扩展，HTTP Cookies就可以解决这个问题。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。</p><blockquote><p>注意，HTTP本质是无状态的，使用<code>Cookies</code>可以创建有状态的会话。同一台机器cookie是相同了，这样服务器就能辨别客户端访问身份；</p></blockquote><h2 id="HTTP-和连接节"><a href="#HTTP-和连接节" class="headerlink" title="HTTP 和连接节"></a>HTTP 和连接节</h2><p>一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。</p><blockquote><p>这也是为什么http协议是建立在tcp协议之上的原因，确保每次连接可靠，但无需实时可用；</p></blockquote><p>HTTP/1.0为每一个请求/响应都打开一个TCP连接，导致了2个缺点：打开一个TCP连接需要多次往返消息传递，因此速度慢。但当多个消息周期性发送时，这样就变得更加高效：暖连接比冷连接更高效。</p><blockquote><p>上边我们说到，http 请求无需实时可用，但从实际网页需求来看，没此简历tcp连接需要3次握手，这种转身就忘记的特性，势必带来了<code>效率</code>问题，因此在http1.1中引入了长连接；也就说我们看到的头部 <code>Connection: keep-alive</code> 信息；</p></blockquote><blockquote><p> 长连接和短连接<br>Connection: keep-alive<br>Connection: close</p></blockquote><p>为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过Connection头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。 </p><p>为了更好的适合HTTP，设计一种更好传输协议的进程一直在进行。Google就研发了一种以UDP为基础，能提供更可靠更高效的传输协议QUIC。</p><h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><p>由于三部分组成：</p><ul><li>请求行</li></ul><p>HTTP请求是由客户端发出的消息，用来使服务器执行动作。比如：<code>GET /background.png HTTP/1.0</code> 起始行 (start-line) 包含三个元素：方法、目标(URL)、协议版本</p><ul><li>请求头 headers</li></ul><p>来自请求的 HTTP headers 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号 (‘:’) 和一个结构取决于 header 的值。 整个 header（包括值）由一行组成，这一行可以相当长。</p><ul><li>请求体 body</li></ul><p>请求的最后一部分是它的 body。不是所有的请求都有一个 body：例如获取资源的请求，GET，HEAD，DELETE 和 OPTIONS，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 POST 请求（包含 HTML 表单数据）。</p><h2 id="http-响应"><a href="#http-响应" class="headerlink" title="http 响应"></a>http 响应</h2><ul><li>状态行</li></ul><p>比如<code>HTTP/1.1 404 Not Found。</code>包含以下信息：协议版本 状态 状态文本；</p><ul><li>headers</li></ul><p>与请求头规则一致；</p><ul><li>响应体 body</li></ul><p>响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如 201 或 204) 的响应，通常不会有 body。</p><h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><h3 id="http1-1-缺点"><a href="#http1-1-缺点" class="headerlink" title="http1.1 缺点"></a>http1.1 缺点</h3><ul><li>header 没有被压缩；</li><li>不同的请求，即使header 信息相似，仍然会重复传输，从共享角度看是显得多余的；</li></ul><h2 id="http2-新特点"><a href="#http2-新特点" class="headerlink" title="http2 新特点"></a>http2 新特点</h2><ul><li>多路复用</li></ul><p>HTTP/2 引入了一个额外的步骤：它将 HTTP/1.x 消息分成帧并嵌入到流 (stream) 中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，这是一个被称为 多路复用 (multiplexing) 的过程，它允许更有效的底层 TCP 连接。</p><p>HTTP/2 帧机制是在 HTTP/1.x 语法和底层传输协议之间增加了一个新的中间层，而没有从根本上修改它，即它是建立在经过验证的机制之上。</p><p>http2 不需要前端做任何升级，只有浏览器支持，服务器端开启，则自动切换到http2上，但必须是https协议网站；</p><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/13819/Binary_framing2.png" alt=""></div><h2 id="http-连接管理"><a href="#http-连接管理" class="headerlink" title="http 连接管理"></a>http 连接管理</h2><p> 包括：短连接、长连接、流水线，连接能管理的是客户端、服务器，中间的代理如果不支持时（路由器），则会使失效；</p><ul><li>http1.0 使用短连接（Connection: close），每次请求时，都需要优建立连接；</li><li>http1.1 默认使用了长连接（Connection: keep-alive），第一次请求时，建立了连接且会保持一段时间，之后请求不在重复建立连接，节省很多开销；</li><li>流水线，多个连续的请求不用等待立即返回就可以被发送，这样就减少了耗费在网络延迟上的时间。但在http1.1中由于各种受限，<br>可应用性没有展开。好的一点是在http2中得到了支持；<br>默认情况下，HTTP 请求是按顺序发出的。下一个请求只有在当前请求收到应答过后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</li></ul><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png" alt=""></div>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>前端知识点分类</title>
      <link href="/2018/11/27/resource-md/"/>
      <url>/2018/11/27/resource-md/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><ul><li>vue.js基本</li><li>vuex 数据状态管理</li><li>axios使用</li><li>vue-router</li><li>pc端ui和移动端ui</li></ul><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><ul><li>闭包</li><li>作用域、作用域链路</li><li>继承</li><li>es2015新特性</li></ul><h1 id="web原理"><a href="#web原理" class="headerlink" title="web原理"></a>web原理</h1><ul><li>http</li><li>304缓存</li><li>cors共享</li><li>浏览器原理:<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li></ul><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><ul><li>koa.js</li></ul><h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><ul><li>webpack</li><li>客户端es6，vue,react配置</li><li>服务器端es6</li></ul><h1 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h1><ul><li>eslint配置和常用标准</li><li>单元测试、覆盖率、用户测试：mocha,karma,e2e<h1 id="了解库"><a href="#了解库" class="headerlink" title="了解库"></a>了解库</h1></li><li>测试框架,比如 Mocha、Jasmine、Karma、Tape</li><li>mock.js</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>抓包工具，如charles使用</li><li>浏览器开发者工具</li><li>编辑器</li><li>检查 Cache 相关 HTTP 首部的工具. <a href="https://redbot.org/" target="_blank" rel="noopener">RedBot</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>rest接口开发模式</li></ul><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>axios遇到OPTIONS请求</title>
      <link href="/2017/06/09/axios/"/>
      <url>/2017/06/09/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。大部分前端工程师在使用axios或者类似fetch库，<br>方便易用，但在CORS跨域资源获取中遇到的问题不少。</p><h2 id="axios-使用"><a href="#axios-使用" class="headerlink" title="axios 使用"></a>axios 使用</h2><p>省略…<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">文档</a></p><h2 id="什么情况下需要-CORS-？"><a href="#什么情况下需要-CORS-？" class="headerlink" title="什么情况下需要 CORS ？"></a>什么情况下需要 CORS ？</h2><p>在下列场景中使用跨域 HTTP 请求：</p><ul><li>由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</li><li>Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</li><li>WebGL 贴图</li><li>使用 drawImage 将 Images/video 画面绘制到 canvas</li></ul><blockquote><p>这次说的是第一种 XMLHttpRequest 发起的跨域 HTTP 请求。</p></blockquote><blockquote><p>大家可能会认为，项目中客户端无非是发起get、post请求，是否允许客户端访问，是服务器端要控制的，只要服务器响应头设置</p></blockquote><p>‘Access-Control-Allow-Origin’:’*’ //所有客户端<br>‘Access-Control-Allow-Origin’:’请求Origin值’  //允许特定客户端</p><p>其次，服务器响应对应个get、post请求类型和路径，这样就OK了。</p><h2 id="真的OK吗"><a href="#真的OK吗" class="headerlink" title="真的OK吗?"></a>真的OK吗?</h2><p>如果是OK的，说明应用场景叫简单；属于<code>简单请求</code>。</p><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”：</p><ul><li>使用下列方法之一：<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type （需要注意额外的限制）</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值仅限于下列三者之一：<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li><li>请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</li><li>请求中没有使用 ReadableStream 对象。</li></ul></li></ul><blockquote><p>满足以上条件时，是简单请求，浏览器发送一次请求。</p></blockquote><h2 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h2><p>与简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS   方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><blockquote><p>在破坏掉简单请求规则后，浏览器首先发起一个method=OPTIONS 的请求，询问服务器是否可以跨域等要求(跨域、方法、自定义头信息等特殊要求)，不满足则直接拒绝；如果同意时，则响应，并且响应头 新增 如下两个字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods&apos; // 服务器所支持的请求方法</span><br><span class="line">Access-Control-Allow-Headers&apos; // 浏览器自定义的头部</span><br></pre></td></tr></table></figure></p></blockquote><p>加入原有请求是POST方式，在获的允许到，浏览器会再次发送一次POST请求；</p><blockquote><p>举个生活中的简单例子，现在小区周边的学校晚上都开放了，允许居民健身运动；<br>比如春节期间，你晚上去学校了，到了门口一看，门卫说假期不对外开放，结果是不能进去健身了，而且白跑一趟，浪费时间和精力，这相当于一个简单请求；<br>优化：去之前先打个电话，询问下是否可以健身，可以就去，不可以就去做其他事情，是不是很省事情呀，这个过程就是 OPTIONS 请求。</p></blockquote><p>继续故事，第二天，你仍然事先打电话询问，然后再做下一步打算，去或不去；时间多了，你会烦死的，门卫也会烦死的；<br>优化：多次电话询问后，门卫聪明了，这次他告诉你，接下来7天内每天都开放，这样你在最近7天肯定不会在打电话先咨询了；这个时间就是 OPTIONS 请求响应头<code>Access-Control-Max-Age</code>中设置缓存时间。</p><p>从中我们应该能感知到，在非简单请求时，浏览器认为是个<code>重请求</code>，超出了服务器默认设置，浏览器会认为可能会被服务器拒绝掉，因此携带大量数据去请求<code>可能白跑一趟</code>，做了优化，先<code>预检请求</code>,看下服务器是否允许，允许多久等，对于跨域请求性能有很大提高；</p><h4 id="当请求满足下述任一条件时，即应首先发送预检请求："><a href="#当请求满足下述任一条件时，即应首先发送预检请求：" class="headerlink" title="当请求满足下述任一条件时，即应首先发送预检请求："></a>当请求满足下述任一条件时，即应首先发送预检请求：</h4><ul><li><p>使用了下面任一 HTTP 方法：</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul></li><li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (but note the additional requirements below)</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值不属于下列之一:<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li><li>请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器。</li><li>请求中使用了ReadableStream对象。</li></ul><h2 id="服务器改造"><a href="#服务器改造" class="headerlink" title="服务器改造"></a>服务器改造</h2><p>大部分情况下，我们设置了跨域，但忽略了对 OPTIONS 响应的处理，最终没有处理或者返回404，错误路径；</p><p>以下是 koa.js 简单处理，OPTIONS 请求返回204，允许访问，当然你可以针对路径设置 OPTIONS；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * [cros跨域处理]</span><br><span class="line"> * @param  &#123;[type]&#125; async (ctx,         next [description]</span><br><span class="line"> * @return &#123;[type]&#125;       [description]</span><br><span class="line"> */</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line">  if (ctx.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">    // 请求method =options，是预检请求</span><br><span class="line">    // 此时做些简单，处理，如果希望访问则如下，不希望时，</span><br><span class="line">    // 设置缓存时间，下次 OPTIONS 请求不会再次发起，直接使用真实的请求如GET、POST、PUT</span><br><span class="line">    // ctx.set(&quot;Access-Control-Max-Age&quot;, 86400000);</span><br><span class="line">    ctx.set(&apos;Access-Control-Allow-Methods&apos;, &apos;OPTIONS, GET, PUT, POST, DELETE&apos;);</span><br><span class="line">    ctx.set(&apos;Access-Control-Allow-Headers&apos;, ctx.header[&apos;access-control-request-headers&apos;]);</span><br><span class="line">    // 发回204状态码，数据是空</span><br><span class="line">    ctx.response.status = 204;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>性能优化</title>
      <link href="/2017/04/23/performance/"/>
      <url>/2017/04/23/performance/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul><li>缓存，如localStorage</li><li>预加载</li></ul><p>利用link rel=”preload” 提前下载，但并不会阻塞页面渲染；<br>as属性 设置加载的媒体类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt;</span><br></pre></td></tr></table></figure></p><ul><li>图片合并</li><li><p>资源加载顺序<br>css 在 head区域加载,<br>js在尾部加载；如果js页面与渲染无关系，可以设置异步；</p></li><li><p>开发PWA 单页面应用；减少页面跳转和资源请求；</p></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul><li>cors缓存，比如options 请设置 头 Access-Control-Max-Age；</li><li>升级到http2协议</li><li>合理的缓存设置</li><li>gzip</li><li>文件压缩，css、js资源</li><li>避免重定向，重定向的后果是客户端需要发起多次请求后才获取到真正资源；</li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>cors跨域请求</li><li>网站资源预加载，在html中设置，包括dns-prefetch DNS;pre-loader css,js;</li><li>网络资源文件大小控制，比如压缩；</li><li>减少请求次数</li></ul><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li>DOM 增删改， 操作次数，最好一次性触发页面reflow、repaint；</li><li>减少作用域链查找，需要频繁访问的变量，最好在本作用域内可以找到；</li><li>精简css文件，混淆、压缩；工程化打包工具会处理；source-map文件在外部或者不输出；</li><li>减小js文件：如删除js文件中重复代码，提取公共组件或函数；</li><li>ajax请求，首选get,会被浏览器缓存，post浏览器不缓存；</li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li>css选择器 深度不宜多；css 引擎是从右往左的，左边不要添加太多限定词；</li><li>css 动画优先于js；</li><li>勿用css表达式；</li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>xss 攻击与防御</title>
      <link href="/2016/08/15/xss/"/>
      <url>/2016/08/15/xss/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS定义"><a href="#XSS定义" class="headerlink" title="XSS定义"></a>XSS定义</h2><p>跨站脚本攻击Cross-site scripting (XSS)是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。</p><blockquote><p>简单点：用户访问网站时，浏览器上执行了<code>不是网站作者意图</code>的代码，而是一个<code>捣乱者</code>的意图，不受控作者控制了，那么<code>捣乱者</code>就可能会窃取访问者的信息；</p></blockquote><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><ul><li>窃取用户的cookie，localStorage;</li><li>将用户重定向到钓鱼网站，比如跳转到一个似真银行网站，当你输入用户名和密码时登录时，实际是在钓鱼网站操作。</li><li>破坏网站内容和结构；</li><li>注入广告、垃圾信息；</li></ul><h2 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h2><p>如果您的网站是与用户有数据交互的，比如论坛，基本流程是用户发帖子、帖子被其他用户浏览，帖子内容网站管理员不可以扭曲，需保证一致性，借此，恶意发帖人会注入一段javascript脚本，然后上传到服务器，最后帖子被查看时，服务器原样吐出来，问题是吐出来时已经不是网站作者的原有意图了；</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>第一种：replace 内容存储前处理，在写入数据库时，过滤掉不安全内容，然后在存储；<br>特点：用户编辑时，已经不是当初内容了，而且服务器上也找不到原来内容；</li><li>第二种：filter 响应时，过滤掉不安全内容，只输出安全内容，像php中有过滤规定标签的函数可以处理；<br>特点：用户编辑时，已经不是当初内容了，但服务器上有；</li><li>第三种，在浏览器端展现时，htmlEncode 编码，使其不可以在浏览器上执行；<br>特点：用户编辑时，看到的就是原有内容；</li></ul><blockquote><p>从内容一致性原则看，第三种最好，文本输入框输入不做限制，也许用户输入标签和脚本 本来就是他的目的，比如技术帖子，正常的需求。但前段工程师在输出页面时必须 htmlEncode 编码输出页面，不给不法者运行环境；</p></blockquote><p>三种各有特点，使用场景不一样，比如第一种，业务需求是不允许输入特殊字符，服务器在存储前做校验，不通过时告知用户，只有符合规则了才给予了保存。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>浏览器的DOM</title>
      <link href="/2016/06/20/dom/"/>
      <url>/2016/06/20/dom/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“Document”对象。</p><p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可翻译成如下的 DOM 树：</p><div align="center"><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png" alt=""></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>.children[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 返回 "[object HTMLHtmlElement]"，证明了 document的第一个子元素是 html，当然也只有一个；</span></span><br><span class="line"><span class="built_in">document</span>.children.length</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h1 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h1><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）</p><div align="center"><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png" alt=""></div><h1 id="webkit-流程"><a href="#webkit-流程" class="headerlink" title="webkit 流程"></a>webkit 流程</h1><div align="center"><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt=""></div><h2 id="css的阻塞"><a href="#css的阻塞" class="headerlink" title="css的阻塞"></a>css的阻塞</h2><h3 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h3><p>如下测试中，文件 <a href="http://127.0.0.1:5000/css" target="_blank" rel="noopener">http://127.0.0.1:5000/css</a> 设置了延迟，其表现：</p><ol><li>在等待过程中，后边的css文件gitbook-min.css 也发出了请求，且下载成功了，说明css不会阻塞其他css文件下载；</li><li>但页面上没有可视内容，是一片空白；</li><li>另外元素 <div id="out">dom</div> 通过 document.getElementById(‘out’) 查看是存在的；</li></ol><blockquote><p>结论：css 不会阻塞其他css下载；不会阻塞dom树构建；但会影响页面渲染；也就是说，页面渲染需要dom tree 和 css rules都准备完成，然后在合并为render tree，最后渲染；卡壳等待原因是在css rules处；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  body&#123;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h3><p>以下：在头部插入脚本时，在<a href="http://127.0.0.1:5000/css" target="_blank" rel="noopener">http://127.0.0.1:5000/css</a> 请求过程中，js未执行，dom未渲染；</p><blockquote><p>结论：css 在请求期间，不会阻塞其他css样式文件，但会阻js；注意加载位置顺序：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://a.apebook.org/gitbook-min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined">alert(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://www.bootcss.com/assets/css/site.min.css?1542483686613"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试三"><a href="#测试三" class="headerlink" title="测试三"></a>测试三</h3><p>以下：css延迟脚本在页面底部，并且设置body是黄色，在执行等待期间，其他css文件已下载，页面是白屏等待，并未看到黄色背景，此时body,div等dom元素都是存在的，页面仍未看到效果；</p><blockquote><p>结论：css文件无论在什么位置，只要没加载完成，都会阻塞dom的渲染; 在渲染之前， Style Rules必须准备就绪，在未就绪前，渲染和dom 都是无意义的；但是浏览器也做了超时控制，不可能无限制等待，因为没有css时，简单的dom也是可用的，因此当外部css文件超时后，就被忽略掉，使用了页面黄色背景，并且完成页面渲染；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://a.apebook.org/gitbook-min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://www.bootcss.com/assets/css/site.min.css?1542483686613"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="undefined">  body&#123;</span></span><br><span class="line"><span class="undefined">    background-color: yellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span> <span class="attr">style</span>=<span class="string">"color: blue;"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试四"><a href="#测试四" class="headerlink" title="测试四"></a>测试四</h3><p>css 延迟100秒，js延迟5秒；</p><ul><li>在css等待响应过程中；js在5后下载成功；</li><li>获取dom不存在，此时页面body元素都看不到；</li><li>js文件下载后，但未被执行；</li></ul><p>分析下浏览器设计思路：</p><ul><li>浏览器在请求下载 css和js外部文件，是不会相互阻塞的下载，阻塞的是执行和使用资源；</li><li>资源的使用是相互依赖的；</li><li>js准备就绪，执行的前提是dom存在；</li><li>若需要dom，则css文件需存在；</li></ul><p>设想：css文件在等待下载中，js文件已经准备好了，如果允许dom准备，那么js文件执行，执行后，此时css文件仍然未下载完成，页面还是看不到，那么执行这个js任务有什么意义；执行js文件后，如果css文件下载完成，页面渲染，试想看到的页面是js的目的吗，加入js更改了背景颜色，后来css又更改了背景颜色，岂不是乱套了。记住，js修改页面时，允许是页面已经就绪，否则混乱了；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:5000/js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span> <span class="attr">style</span>=<span class="string">"color:blue;"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试五"><a href="#测试五" class="headerlink" title="测试五"></a>测试五</h3><p>css 延迟100秒，js延迟5秒；</p><ul><li>页面在css、js等待下载过程中，dom很快生成了，但页面是空白的，因为还没有渲染；</li><li>5秒后，js文件下载完成，css还在等待下载中，但js未执行，即使dom存在了，因为css文件在前边，如果此时js执行了，后边css文件又影响了页面渲染，那么js执行的效果未必是开发者可以控制的或开发者的目的；</li></ul><blockquote><p>结论：页面在等待下载css过程中，在生成新的渲染之前，是不允许执行js的，必须等待生成新的渲染上下文后，再执行js；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://127.0.0.1:5000/css2&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;out&quot; style=&quot;color:blue;&quot;&gt;dom&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1:5000/js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="js-阻塞"><a href="#js-阻塞" class="headerlink" title="js 阻塞"></a>js 阻塞</h2><p>js延迟10秒；css 延迟3秒，</p><p>如下测试中，文件 <a href="http://127.0.0.1:5000/js" target="_blank" rel="noopener">http://127.0.0.1:5000/js</a> 设置了延迟返回，是个js文件，有个<code>alert(1)</code>片段；</p><ul><li>在js和css都未完成下载时，dom不存在；</li><li>在js等待下载，css已下载，dom仍然不存在；</li><li>js下载完成，执行了alert(1)，但为关闭，也就是说脚本执行了，但未执行完之前，dom仍然不存在；</li><li>js完成执行后，生成了dom ,渲染了页面；</li></ul><blockquote><p>结论：js文件会阻塞后续js文件执行和dom生成,为了尽快渲染dom，应该js文件在页面底部加载，头部禁止，除非业务必须使用的资源脚本；<br>js文件是同步执行，必须执行完成一个后，才能执行下一个js或页面渲染；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:5000/js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"http://127.0.0.1:5000/css2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"out"</span>&gt;</span>dom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="浏览器js和js位置"><a href="#浏览器js和js位置" class="headerlink" title="浏览器js和js位置"></a>浏览器js和js位置</h2><p>位置对执行顺序的影响</p><ul><li>css规则：css在文件头部，目的是准备就绪css rules，规则未准备好之前页面不渲染，禁止用户看页面，防止页面跳动;</li><li>页面渲染：执行body区域，生成dom tree,同时与css合并生成render tree,最终渲染完成，用户看到初始页面；</li><li>执行脚本：顺序执行脚本任务，动态更改css和dom，重新完成一次渲染；</li></ul><blockquote><p>以上是用户体验最好的加载顺序；<br>资源请求下载是异步的，不会被阻塞；<br>js和css相互阻塞的是执行、执行、执行；</p></blockquote>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>prototype</title>
      <link href="/2015/10/12/prototype/"/>
      <url>/2015/10/12/prototype/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——<code>每个对象拥有一个原型对象</code>，对象以其原型为<code>模板</code>、从原型<code>继承方法和属性</code>。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><p>javascript 创建对象</p><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>手工作坊，生成的对象看似一致，实际是没有任何关系的，且生成效率很低；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mycar = &#123;</span><br><span class="line">  name : &apos;BMW&apos;,</span><br><span class="line">  color: &apos;black&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>加工厂，根据需要，零件快速组装，出厂都是属性名都是一样的，其他配置用户后期可以加装(自己增加属性);</p><p>特点：</p><ul><li>快速产出对象，对象之间是独立的个体；</li><li>实例对象之间仍然看不出有什么关联关系；比如看不出是同一个厂家生产的；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function factory(name, color) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    color: color</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myCar = factory(&apos;BMW&apos;,&apos;black&apos;);</span><br><span class="line"></span><br><span class="line">var yourCar = factory(&apos;MINI&apos;,&apos;Blue&apos;);</span><br></pre></td></tr></table></figure><h2 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h2><p>使用Object.create方法；</p><p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>。</p><p>语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto, [propertiesObject])</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const o = Object.create(null);</span><br><span class="line">// o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const o2 = Object.create(&#123;&#125;);</span><br><span class="line">// o2 = &#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：o和o2 差异很大，o 没有任何继承属性和方法；o2却有</p></blockquote><h2 id="方式3-1"><a href="#方式3-1" class="headerlink" title="方式3"></a>方式3</h2><p>构造函数，使用关键字<code>new</code>去创建一个对象，new后边的函数构造函数，可以认为是个模板，模板中出来的产品肯定是一样的，相同的特性；</p><p>使用实例 <code>myCar.__proto__.constructor</code> 可以查看构造方法，这样我们就可以知道他的来源了；</p><p>在javascript中，实例对象上都有一个影藏属性<code>__proto__</code>,指向构造函数的<code>prototype</code>属性；</p><p><code>myCar.__proto__.constructor == Car</code> 返回 true</p><p><code>myCar.__proto__ == Car.prototype</code> 返回 true</p><p>myCar.<strong>proto</strong>.constructor == yourCar.<strong>proto</strong>.constructor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Car(name, color) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myCar = new Car(&apos;BMW&apos;,&apos;black&apos;);</span><br><span class="line"></span><br><span class="line">var yourCar = new Car(&apos;MINI&apos;,&apos;Blue&apos;);</span><br></pre></td></tr></table></figure><p>此方式是创建一个用户自定义的对象需要两步：</p><p>通过编写函数来定义对象类型。<br>通过new来创建对象实例。<br>创建一个对象类型，需要创建一个指定其名称和属性的函数；对象的属性可以指向其他对象，看下面的例子：</p><p>当代码 new Car(…) 执行时，会发生以下事情：</p><ol><li>一个继承自 Car.prototype 的新对象被创建。 使用 myCar.<strong>proto</strong>找到 Car.prototype；</li><li>使用指定的参数调用构造函数 Car ，并将 this 绑定到新创建的对象。new Car 等同于 new Car()Car 不带任何参数调用的情况。</li><li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li></ol><p>## </p><ul><li>Oject 对象也是从函数继承过来的</li></ul><p>Object.<strong>proto</strong> == Function.prototype</p><ul><li>Object 是个函数，返回 “[object Function]”</li></ul><p>Object.prototype.toString.call(Object)</p><ul><li>函数 function foo(){} 与 Object函数 都继承与Function;<br>abc.<strong>proto</strong> == Object.<strong>proto</strong> 是相等的；</li></ul><p>你可以使用 Function.prototype 属性将共享属性添加到以前定义的对象类型。这定义了一个由该函数创建的所有对象共享的属性，而不仅仅是对象类型的其中一个实例。下面的代码将一个值为null的color属性添加到car类型的所有对象，然后仅在实例对象car1中用字符串“black”覆盖该值。详见 prototype。</p><p>浏览器首先检查，person1 对象是否具有可用的 valueOf() 方法。<br>如果没有，则浏览器检查 person1 对象的原型对象（即 Person构造函数的prototype属性所指向的对象）是否具有可用的 valueof() 方法。<br>如果也没有，则浏览器检查 Person() 构造函数的prototype属性所指向的对象的原型对象（即 Object构造函数的prototype属性所指向的对象）是否具有可用的 valueOf() 方法。这里有这个方法，于是该方法被调用。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript 继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css</title>
      <link href="/2015/01/30/css/"/>
      <url>/2015/01/30/css/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-实际上如何工作？"><a href="#CSS-实际上如何工作？" class="headerlink" title="CSS 实际上如何工作？"></a>CSS 实际上如何工作？</h2><p>当浏览器显示文档时，它必须将文档的内容与其样式信息结合。它分两个阶段处理文档：</p><p>浏览器将 HTML 和 CSS 转化成 DOM （文档对象模型）。DOM在计算机内存中表示文档。它把文档内容和其样式结合在一起。<br>浏览器显示 DOM 的内容。</p><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/11781/rendering.svg" alt=""></div><h2 id="如何将你的-CSS-应用到你的-HTML-上"><a href="#如何将你的-CSS-应用到你的-HTML-上" class="headerlink" title="如何将你的 CSS 应用到你的 HTML 上"></a>如何将你的 CSS 应用到你的 HTML 上</h2><ul><li>外部样式表</li><li>内部样式表</li><li>内联样式</li></ul><h2 id="CSS-声明"><a href="#CSS-声明" class="headerlink" title="CSS 声明"></a>CSS 声明</h2><p>由于 属性名和属性值 结对构成；</p><div style="text-align: center;"><img src="https://mdn.mozillademos.org/files/16188/css_syntax_-_declaration.png" alt=""></div><h2 id="css-选择器分类"><a href="#css-选择器分类" class="headerlink" title="css 选择器分类"></a>css 选择器分类</h2><ul><li>简单选择器（Simple selectors）：通过元素类型、class 或 id 匹配一个或多个元素。</li><li>属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。</li><li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。</li><li>伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 </li><li>组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。</li><li>多重选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li></ul><h3 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h3><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类不是选择元素，而是元素的某些部分，或仅在某些特定上下文中存在的元素。它们有两种主要类型 ： 伪类和伪元素。</p><p>一个 CSS  伪类（pseudo-class） 是<code>一个以冒号(:)</code>作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:active</span></span><br><span class="line"><span class="selector-pseudo">:any</span></span><br><span class="line"><span class="selector-pseudo">:checked</span></span><br><span class="line"><span class="selector-pseudo">:default</span></span><br><span class="line"><span class="selector-pseudo">:dir()</span></span><br><span class="line"><span class="selector-pseudo">:disabled</span></span><br><span class="line"><span class="selector-pseudo">:empty</span></span><br><span class="line"><span class="selector-pseudo">:enabled</span></span><br><span class="line"><span class="selector-pseudo">:first</span></span><br><span class="line"><span class="selector-pseudo">:first-child</span></span><br><span class="line"><span class="selector-pseudo">:first-of-type</span></span><br><span class="line"><span class="selector-pseudo">:fullscreen</span></span><br><span class="line"><span class="selector-pseudo">:focus</span></span><br><span class="line"><span class="selector-pseudo">:hover</span></span><br><span class="line"><span class="selector-pseudo">:indeterminate</span></span><br><span class="line"><span class="selector-pseudo">:in-range</span></span><br><span class="line"><span class="selector-pseudo">:invalid</span></span><br><span class="line"><span class="selector-pseudo">:lang()</span></span><br><span class="line"><span class="selector-pseudo">:last-child</span></span><br><span class="line"><span class="selector-pseudo">:last-of-type</span></span><br><span class="line"><span class="selector-pseudo">:left</span></span><br><span class="line"><span class="selector-pseudo">:link</span></span><br><span class="line"><span class="selector-pseudo">:not()</span></span><br><span class="line"><span class="selector-pseudo">:nth-child()</span></span><br><span class="line"><span class="selector-pseudo">:nth-last-child()</span></span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type()</span></span><br><span class="line"><span class="selector-pseudo">:nth-of-type()</span></span><br><span class="line"><span class="selector-pseudo">:only-child</span></span><br><span class="line"><span class="selector-pseudo">:only-of-type</span></span><br><span class="line"><span class="selector-pseudo">:optional</span></span><br><span class="line"><span class="selector-pseudo">:out-of-range</span></span><br><span class="line"><span class="selector-pseudo">:read-only</span></span><br><span class="line"><span class="selector-pseudo">:read-write</span></span><br><span class="line"><span class="selector-pseudo">:required</span></span><br><span class="line"><span class="selector-pseudo">:right</span></span><br><span class="line"><span class="selector-pseudo">:root</span></span><br><span class="line"><span class="selector-pseudo">:scope</span></span><br><span class="line"><span class="selector-pseudo">:target</span></span><br><span class="line"><span class="selector-pseudo">:valid</span></span><br><span class="line"><span class="selector-pseudo">:visited</span></span><br></pre></td></tr></table></figure><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是<code>两个冒号 (::)</code>， 同样是添加到选择器后面去选择某个元素的某个部分。</p><p>我最熟悉的清除浮动 <code>.cleanfix</code>，就是利用了伪元素，给其设置样式和内容以此影响浮动；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::after</span><br><span class="line">::before</span><br><span class="line">::first-letter</span><br><span class="line">::first-line</span><br><span class="line">::selection</span><br><span class="line">::backdrop</span><br></pre></td></tr></table></figure></p><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><table><thead><tr><th>名称</th><th style="text-align:center">组合器</th><th style="text-align:left">选择</th></tr></thead><tbody><tr><td>选择器组</td><td style="text-align:center">A,B</td><td style="text-align:left">匹配满足A（和/或）B的任意元素</td></tr><tr><td>后代选择器</td><td style="text-align:center">A B</td><td style="text-align:left">匹配B元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）</td></tr><tr><td>子选择器</td><td style="text-align:center">A &gt; B</td><td style="text-align:left">匹配B元素，满足条件：B是A的<code>直接子节点</code></td></tr><tr><td>相邻兄弟选择器</td><td style="text-align:center">A + B</td><td style="text-align:left">匹配B元素，满足条件：B是A的<code>下一个兄弟节点</code>（AB有相同的父结点，并且B紧跟在A的后面）</td></tr><tr><td>通用兄弟选择器</td><td style="text-align:center">A ~ B</td><td style="text-align:left">匹配B元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）</td></tr></tbody></table><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>颜色是由 Red、Green、Blue三个颜色调和，每个颜色256种</p><ul><li>名称：如 <code>red</code></li><li>16进制 如 <code>#ffff00</code>,其中两个表示一个颜色通道</li><li>RGB,如 <code>rgb(255,0,0);</code>, rbg是个函数，会帮我们计算，差别是每个是10进制</li><li><p>HSL 支持度比RGB稍微差一点的是HSL（旧版本的IE浏览器不支持），这是在众多开发者对其产生兴趣之后才实现的——hsl()函数接受三个表示色调、饱和度以及明度的参数，使用与上述三种不同的方式来区分大约1670万种颜色：</p><ul><li>色调：颜色的底色调。这个值在0到360之间，表示色轮的角度。</li><li>饱和度：饱和度是多少？这需要一个从0-100%的值，其中0是没有颜色（它将显示为灰色），100%是全彩色饱和度。</li><li>明度：颜色有多亮或明亮？这需要一个从0-100%的值，其中0是无光（它会出现全黑的），100%是充满光的（它会出现全白）。</li></ul></li><li><p>RGBA 和 HSLA 是RGB、HSL的对应透明度transparency函数；</p></li></ul><blockquote><p>颜色数值颜色，在chrome开发者工具，颜色面板可以转化查看;css更多函数值另查手册；</p></blockquote><blockquote><p><code>RGBA透明度与opacity属性差别</code>，opacity除了影响自身透明，还影响了子节点透明度，rgba只设置了自己；</p></blockquote><h3 id="选择器计算规则"><a href="#选择器计算规则" class="headerlink" title="选择器计算规则"></a>选择器计算规则</h3><p>一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字：</p><ul><li>千位：如果声明是在style 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。</li><li>百位：在整个选择器中每包含一个ID选择器就在该列中加1分。</li><li>十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。</li><li>个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。</li></ul><h3 id="float-元素如何工作"><a href="#float-元素如何工作" class="headerlink" title="float 元素如何工作"></a>float 元素如何工作</h3><p>浮动元素会脱离正常的文档布局流，并吸附到<code>其父容器的左边 flaot:left</code>。在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其右侧的空间。</p><p>注意浮动内容仍然遵循盒子模型诸如外边距和边界。我们设置一下图片右侧的外边距就能阻止右侧的文字紧贴着图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">.clearfix &#123;</span><br><span class="line">  zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.fn-clear &#123;</span><br><span class="line">  zoom: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  display: block;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  content: &quot; &quot;;</span><br><span class="line">  clear: both</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫外边距折叠, 我们之前也遇到过。</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
